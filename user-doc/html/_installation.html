<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: Installation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script>
   var redpath = "";
   
   function showPath(eg,name) {
     var i; var y = document.getElementsByName(redpath);
     for (i=0; i < y.length; i++ ) { y[i].style.color="black"; }
     var x = document.getElementsByName(name); redpath=name;
     for (i = 0; i < x.length; i++) { x[i].style.color="red"; }
     var valid="value_details_".concat(eg);
     var valueField = document.getElementById(valid);
     var dataField = document.getElementById(name);
     valueField.innerHTML = dataField.innerHTML;
   }
   function swapInput(name) {
     var btn = document.getElementById(name + "_button");
     var mydiv = document.getElementById("input_" + name);
     if( btn.textContent=="expand shortcuts" ) {
         btn.textContent = "contract shortcuts";
         var dataField = document.getElementById(name + "long");
         mydiv.innerHTML = dataField.innerHTML;
     } else if( btn.textContent=="contract shortcuts" ) {
         btn.textContent = "expand shortcuts";
         var dataField = document.getElementById(name + "short");
         mydiv.innerHTML = dataField.innerHTML;
     }
   }
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../developer-doc/html/index.html"> <img src="user-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_installation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"></div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this page you can learn how to <a class="el" href="_installation.html#ConfiguringPlumed">configure</a>, <a class="el" href="_installation.html#CompilingPlumed">compile</a>, and <a class="el" href="_installation.html#InstallingPlumed">install</a> PLUMED. For those of you who are impatient, the following might do the job: </p><pre class="fragment">&gt; ./configure --prefix=/usr/local
&gt; make -j 4
&gt; make doc # this is optional and requires proper doxygen version installed
&gt; make install
</pre><p> Notice that <code>make install</code> is not strictly necessary as plumed can be used from the compilation directory. This is very useful so as to quickly test the implementation of new features. However, we strongly recommend to perform a full install.</p>
<p>Once the above is completed the <code>plumed</code> executable should be in your execution path and you will be able to use PLUMED to analyze existing trajectories or play with the Lennard-Jones code that is included. However, because PLUMED is mostly used to bias on the fly simulations performed with serious molecular dynamics packages, you can find instructions about how to <a class="el" href="_installation.html#Patching">patch </a> your favorite MD code so that it can be combined with PLUMED below. Again, if you are impatient, something like this will do the job: </p><pre class="fragment">&gt; cd /md/root/dir
&gt; plumed patch -p
</pre><p> Then compile your MD code. For some MD codes these instructions are insufficient. It is thus recommended that you read the instructions at the end of this page. Notice that MD codes could in principle be "PLUMED ready" in their official distribution. If your favorite MD code is available "PLUMED ready" you will have to compile PLUMED first, then (optionally) install it, then check the MD codes' manual to discover how to link it.</p>
<h1><a class="anchor" id="SupportedCompilers"></a>
Supported compilers</h1>
<p>As of PLUMED 2.10, we require a compiler that supports C++17.</p>
<p>Notice that the <code>./configure</code> script verifies that your compiler supports C++17. Some compilers do not declare full support, but implement anyway a number of C++17 features sufficient to compile PLUMED. In case you see a warning about C++17 support during <code>./configure</code> please make sure that PLUMED compiles correctly and, if possible, execute the regtests (using <code>make regtest</code>). Notice that we regularly test a number of compilers on travis-ci, and at least those compilers are guaranteed to be able to compile PLUMED correctly.</p>
<h1><a class="anchor" id="ConfiguringPlumed"></a>
Configuring PLUMED</h1>
<p>The <code>./configure</code> command just generates a Makefile.conf file and a sourceme.sh file. In PLUMED 2.0 these files were prepared and stored in the directory configurations/. The new ones generated by ./configure are similar to the old ones but are not completely compatible. In particular, some of the -D options have been changed in version 2.2, and several new variables so as to specify the installation directories have been added. For this reason, you now should run <code>./configure</code> again. Anyway, it should be easy to enforce a similar setup with autoconf by passing the proper arguments on the command line. If you have problems on your architecture, please report them to the mailing list.</p>
<p>Useful command line options for ./configure can be found by typing </p><pre class="fragment">&gt; ./configure --help
</pre><p> PLUMED is made up of modules. Some of them are on by default, some others aren't. Since version 2.3, the activation of modules should be made during configuration using the <code>--enable-modules</code> option (see <a class="el" href="mymodules.html">List of modules</a>).</p>
<p>Notice that some of the methods within PLUMED depend on external libraries which are looked for by configure. You can typically avoid looking for a library using the "disable" syntax, e.g. </p><pre class="fragment">&gt; ./configure --disable-mpi --disable-gsl
</pre><p>Notice that when MPI search is enabled (by default) compilers such as "mpic++" and "mpicxx" are searched for first. On the other hand, if MPI search is disabled ("./configure --disable-mpi") non-mpi compilers are searched for. Notice that only a few of the possible compiler name are searched. Thus, compilers such as "g++-mp-4.8" should be explicitly requested with the CXX option.</p>
<p>You can better control which compiler is used by setting the variables CXX and CC. E.g., to use Intel compilers use the following command: </p><pre class="fragment">&gt; ./configure CXX=icpc CC=icc
</pre><p> Notice that we are using icpc in this example, which is not an MPI compiler as a result MPI will not be enabled. Also consider that this is different with respect to what some other configure script does in that variables such as MPICXX are completely ignored here. In case you work on a machine where CXX is set to a serial compiler and MPICXX to a MPI compiler, to compile with MPI you should use </p><pre class="fragment">&gt; ./configure CXX="$MPICXX"
</pre><dl class="section warning"><dt>Warning</dt><dd>This procedure could be somehow confusing since many other programs behave in a different way. The flag <code>--enable-mpi</code> is perfectly valid but is not needed here. Autoconf will check if a code containing MPI calls can be compiled, and if so it will enable it. <code>--disable-mpi</code> could be used if you are using a compiler that supports MPI but you don't want PLUMED to be compiled with MPI support. Thus the correct way to enable MPI is to pass to ./configure the name of a C++ compiler that implements MPI using the CXX option. In this way, MPI library is treated similarly to all the other libraries that PLUMED tries to link by default.</dd></dl>
<p>To tune the compilation options you can use the CXXFLAGS variable: </p><pre class="fragment">&gt; ./configure CXXFLAGS=-O3
</pre><p>If you are implementing new functionality and want to build with debug flags in place so as to do some checking you can use </p><pre class="fragment">&gt; ./configure --enable-debug
</pre><p> This will perform some extra check during execution (possibly slowing down PLUMED) and write full symbol tables in the executable (making the final executable much larger).</p>
<p>The main goal of the automatic configure is to find the libraries. When they are stored in unconventional places it is thus sensible to tell autoconf where to look! To do this there are some environment variable that can be used to instruct the linker which directories it should search for libraries inside. These variables are compiler dependent, but could have been set by the system administrator so that libraries are found without any extra flag. Our suggested procedure is to first try to configure without any additional flags and to then check the log so as to see whether or not the libraries were properly detected.</p>
<p>If a library is not found during configuration, you can try to use options to modify the search path. For example if your gsl libraries is in /opt/local (this is where MacPorts put it) and configure is not able to find it you can try </p><pre class="fragment">&gt; ./configure LDFLAGS=-L/opt/local/lib CPPFLAGS=-I/opt/local/include
</pre><p> Notice that PLUMED will first try to link a routine from say gsl without any additional flag, and then in case of failure will retry adding "-lgsl" to the LIBS options. If also this does not work, the gsl library will be disabled and some features will not be available. This procedure allows you to use libraries with custom names. So, if your gsl library is called /opt/local/lib/libmygsl.so you can link it with </p><pre class="fragment">&gt; ./configure LDFLAGS=-L/opt/local/lib CPPFLAGS=-I/opt/local/include LIBS=-lmygsl
</pre><p> In this example, the linker will directly try to link <code>/opt/local/lib/libmygsl.so</code>. This rule is true for all the libraries, so that you will always be able to link a specific version of a library by specifying it using the LIBS variable.</p>
<p>Since version 2.3.2, the search for the library functions passing to the linker a flag with the standard library name (in the gsl example, it would be <code>-lgsl</code>) can be skipped by using the option <code>--disable-libsearch</code>. Notice that in this manner only libraries that are explicitly passed using the <code>LIBS</code> option will be linked. For instance </p><pre class="fragment">&gt; ./configure --disable-libsearch LIBS=-lgsl
</pre><p> will make sure that only gsl is linked and, for instance, BLAS and LAPACK libraries are not. This might be useful when installing PLUMED within package managers such as MacPorts to make sure that only desired libraries are linked and thus to avoid to introduce spurious dependencies. The only exception to this rule is <code>-ldl</code>, which is anyway a system library on Linux.</p>
<dl class="section warning"><dt>Warning</dt><dd>On OSX it is common practice to hard code the full path to libraries in the libraries themselves. This means that, after having linked a shared library, that specific shared library will be searched in the same place (we do the same for the <code>libplumed.dylib</code> library, which has an install name hard coded). On the other hand, on Linux it is common practice not to hard code the full path. This means that if you use the <code>LDFLAGS</code> option to specify the path to the libraries you want to link to PLUMED (e.g. <code>./configure LDFLAGS="-L/path"</code>) these libraries might not be found later. The visible symptom is that <code>src/lib/plumed-shared</code> will not be linked correctly. Although the file 'src/lib/plumed-shared' is not necessary, being able to produce it means that it will be possible to link PLUMED dynamically with MD codes later. The easiest solution is to hard code the library search path in this way: <pre class="fragment">&gt; ./configure LDFLAGS="-L/path -Wl,-rpath,/path"
</pre> Notice that as of PLUMED v2.4 it is possible to use the configure option <code>--enable-rpath</code> to automatically hard code the path defined in <code>LIBRARY_PATH</code>: <pre class="fragment">&gt; ./configure LIBRARY_PATH=/path --enable-rpath
</pre> In this way, the search path used at link time (<code>LIBRARY_PATH</code>) and the one saved in the <code>libplumed.so</code> library will be consistent by construction. In a typical environment configured using module framework (<a href="http://modules.sourceforge.net">http://modules.sourceforge.net</a>), <code>LIBRARY_PATH</code> will be a variable containing the path to all the modules loaded at compilation time.</dd></dl>
<p>PLUMED needs BLAS and LAPACK. These are treated slightly different from other libraries. The search is done in the usual way (i.e., first look for them without any link flag, then add "-lblas" and "-llapack", respectively). As such if you want to use a specific version of BLAS or LAPACK you can make them available to configure by using </p><pre class="fragment">&gt; ./configure LDFLAGS=-L/path/to/blas/lib LIBS=-lnameoflib
</pre><p> If the functions of these libraries are not found, the compiler looks for a version with a final underscore added. Finally, since BLAS and LAPACK are compulsory in PLUMED, you can use a internal version of these libraries that comes as part of PLUMED. If all else fails the internal version of BLAS and LAPACK are the ones that will be used by PLUMED. If you wish to disable any search for external libraries (e.g. because the system libraries have problems) this can be done with </p><pre class="fragment">&gt; ./configure --disable-external-blas
</pre><p> Notice that you can also disable external LAPACK only, that is use internal LAPACK with external BLAS using </p><pre class="fragment">&gt; ./configure --disable-external-lapack
</pre><p> Since typically it is the BLAS library that can be heavily optimized, this configuration should not provide significant slowing down and could be used on systems where native LAPACK libraries have problems.</p>
<p>As a final resort, you can also edit the resulting Makefile.conf file. Notable variables in this file include:</p><ul>
<li>DYNAMIC_LIB : these are the libraries needed to compile the PLUMED library (e.g. -L/path/to/gsl -lgsl etc). Notice that for the PLUMED shared library to be compiled properly these should be dynamic libraries. Also notice that PLUMED preferentially requires BLAS and LAPACK library; see <a class="el" href="_installation.html#BlasAndLapack">BLAS and LAPACK</a> for further info. Notice that the variables that you supply with <code>configure LIBS=something</code> will end up in this variable. This is a bit misleading but is required to keep the configuration files compatible with PLUMED 2.0.</li>
<li>LIBS : these are the libraries needed when patching an MD code; typically only "-ldl" (needed to have functions for dynamic loading).</li>
<li>CPPFLAGS : add here definition needed to enable specific optional functions; e.g. use -D__PLUMED_HAS_GSL to enable the gsl library</li>
<li>SOEXT : this gives the extension for shared libraries in your system, typically "so" on UNIX, "dylib" on mac; If your system does not support dynamic libraries or, for some other reason, you would like a static executable you can just set this variable to a blank ("SOEXT=").</li>
</ul>
<h2><a class="anchor" id="BlasAndLapack"></a>
BLAS and LAPACK</h2>
<p>We tried to keep PLUMED as independent as possible from external libraries and as such those features that require external libraries are optional. However, to have a properly working version of plumed PLUMED you need BLAS and LAPACK libraries. We would strongly recommend you download these libraries and install them separately so as to have the most efficient possible implementations of the functions contained within them. However, if you cannot install BLAS and LAPACK, you can use the internal ones. Since version 2.1, PLUMED uses a configure script to detect libraries. In case system LAPACK or BLAS are not found on your system, PLUMED will use the internal replacement.</p>
<p>We have had a number of emails (and have struggled ourselves) with ensuring that PLUMED can link BLAS and LAPACK. The following describes some of the pitfalls that you can fall into and a set of sensible steps by which you can check whether or not you have set up the configuration correctly.</p>
<p>Notice first of all that the DYNAMIC_LIB variable in the Makefile.conf should contain the flag necessary to load the BLAS and LAPACK libraries. Typically this will be -llapack -lblas, in some case followed by -lgfortran. Full path specification with -L may be necessary and on some machines the BLAS and LAPACK libraries may not be called -llapack and -lblas. Everything will depend on your system configuration.</p>
<p>Some simple to fix further problems include:</p><ul>
<li>If the linker complains and suggests recompiling LAPACK with -fPIC, it means that you have static LAPACK libraries. Either install dynamic LAPACK libraries or switch to static compilation of PLUMED by stopping to set the SOEXT variable in the configuration file.</li>
<li>If the linker complains about other missing functions (typically starting with "for_" prefix) then you should also link some Fortran libraries. PLUMED is written in C++ and often C++ linkers do not include Fortran libraries by default. These libraries are required for LAPACK and BLAS to work. Please check the documentation of your compiler.</li>
<li>If the linker complains that dsyevr_ cannot be found, try adding -DF77_NO_UNDERSCORE to CPPFLAGS Notice that "./configure" should automatically try this solution.</li>
</ul>
<h2><a class="anchor" id="installation-vmdplugins"></a>
VMD trajectory plugins</h2>
<p>PLUMED source code already includes a few selected VMD molfile plugins so as to read a small number of additional trajectory formats (e.g., dcd, gromacs files, pdb, and amber files). If you configure PLUMED with the full set of VMD plugins you will be able to read many more trajectory formats, basically all of those supported by VMD. To this aim, you need to download the SOURCE of VMD, which contains a plugins directory. Adapt build.sh and compile it. At the end, you should get the molfile plugins compiled as a static library <code>libmolfile_plugin.a</code>. Locate said file and <code>libmolfile_plugin.h</code>, they should be in a directory called <code>/pathtovmdplugins/ARCH/molfile</code> (e.g. <code>/pathtovmdplugins/MACOSXX86_64/molfile</code>). Also locate file <code>molfile_plugin.h</code>, which should be in <code>/pathtovmdplugins/include</code>. Then customize the configure command with something along the lines of:</p>
<pre class="fragment">&gt; ./configure LDFLAGS="-L/pathtovmdplugins/ARCH/molfile" CPPFLAGS="-I/pathtovmdplugins/include -I/pathtovmdplugins/ARCH/molfile"
</pre><p>Notice that it might be necessary to add to <code>LDFLAGS</code> the path to your TCL interpreter, e.g.</p>
<pre class="fragment">&gt; ./configure LDFLAGS="-ltcl8.5 -L/mypathtotcl -L/pathtovmdplugins/ARCH/molfile" \
            CPPFLAGS="-I/pathtovmdplugins/include -I/pathtovmdplugins/ARCH/molfile"
</pre><p>Then, rebuild plumed.</p>
<h2><a class="anchor" id="installation-libtorch"></a>
LibTorch</h2>
<p>In order to use machine learning models optimized with PyTorch (as in the <a class="el" href="_p_y_t_o_r_c_h.html">PYTORCH</a> module) or specific actions implemented in the <a class="el" href="_i_s_d_b.html">PLUMED-ISDB</a> module, one needs to link the LibTorch C++ library. To do so, one can follow these instructions to download the pre-compiled library and configure PLUMED to use it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Libtorch APIs are still in beta phase, so there might be breaking changes in newer versions. Currently, versions between 1.8.* and 2.0.0 have been tested. Please note that if you want to link a different version it might be necessary to manually specify the required libraries within LIBS in configure.</dd></dl>
<p><b>Download LibTorch C++ API library</b></p>
<p>You can download the pre-built LibTorch library from their <a href="https://pytorch.org/get-started/locally/">website</a>. For example, the following script downloads the <a href="https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-2.0.0%2Bcpu.zip"><code>libtorch-cxx11-abi-shared-with-deps-2.0.0%2Bcpu.zip</code></a> (2.0.0, CPU, with C++11 ABI compatibility).</p>
<pre class="fragment">wget https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-2.0.0%2Bcpu.zip 
unzip libtorch-cxx11-abi-shared-with-deps-2.0.0+cpu.zip ; 
</pre><p>If you have a GPU, you might want to use the CUDA-accelerated version of LibTorch. For example, the following script downloads the <a href="https://download.pytorch.org/libtorch/cu117/libtorch-shared-with-deps-2.0.0%2Bcu117.zip"><code>libtorch-shared-with-deps-2.0.0%2Bcu117.zip</code></a> (2.0.0, GPU, Cuda 11.7, pre-cxx11 ABI binary).</p>
<pre class="fragment">wget https://download.pytorch.org/libtorch/cu117/libtorch-shared-with-deps-2.0.0%2Bcu117.zip 
unzip libtorch-shared-with-deps-2.0.0+cu117.zip 
</pre><p>In both CPU and GPU cases, the location of the include and library files need to be exported in the environment:</p>
<pre class="fragment">LIBTORCH=${PWD}/libtorch
export CPATH=${LIBTORCH}/include/torch/csrc/api/include/:${LIBTORCH}/include/:${LIBTORCH}/include/torch:$CPATH
export INCLUDE=${LIBTORCH}/include/torch/csrc/api/include/:${LIBTORCH}/include/:${LIBTORCH}/include/torch:$INCLUDE
export LIBRARY_PATH=${LIBTORCH}/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=${LIBTORCH}/lib:$LD_LIBRARY_PATH
</pre><p>Remember to add these lines also in your <code>~/.bashrc</code> or <code>~/.bash_profile</code> file.</p>
<p><b>Configure PLUMED</b></p>
<p>Once the environment variables are set, we can configure PLUMED with the <code>--enable-libtorch</code> keyword:</p>
<pre class="fragment">&gt; ./configure --enable-libtorch
</pre><p><b>Notes</b></p><ul>
<li>In order to activate also the <a class="el" href="_p_y_t_o_r_c_h.html">PYTORCH</a> module one needs to add <code>--enable-modules=pytorch</code> or <code>--enable-modules=all</code>.</li>
<li><code>--enable-libtorch</code> will first try first to link the CUDA-enabled library and if it does not found it will try to link the CPU-only version.</li>
<li>To verify that the linking of LibTorch is succesful, one should look at the output of the configure commands: <code>checking libtorch[cpu/cuda] [without extra libs/with -ltorch_cpu ... ]</code>. If any of these commands are succesfull, it will return <code>... yes</code>. Otherwise, the configure will display a warning (and not an error!) that says: <code>configure: WARNING: cannot enable __PLUMED_HAS_LIBTORCH</code>. In this case, it is recommended to examine the output of the above commands in the config.log file to understand the reason (e.g. it cannot find the required libraries).</li>
<li>If you want to use the pre-cxx11 ABI LibTorch binaries (useful for instance when installing it on an HPC cluster) then you should download the related version from PyTorch website (e.g. <a href="https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-2.0.0%2Bcpu.zip"><code>libtorch-shared-with-deps-2.0.0%2Bcpu.zip</code></a>) and add the following option to the configure: <code>CXXFLAGS="-D_GLIBCXX_USE_CXX11_ABI=0"</code>.</li>
</ul>
<h2><a class="anchor" id="additional-modules"></a>
Additional Modules</h2>
<p>PLUMED includes some additional modules that by default are not compiled, but can be enabled during configuration. You can use the option <code>--enable-modules</code> to activate some of them, e.g.</p>
<pre class="fragment">&gt; ./configure --enable-modules=module1name+module2name
</pre><p>For more information on modules see <a class="el" href="mymodules.html">List of modules</a>.</p>
<h1><a class="anchor" id="CompilingPlumed"></a>
Compiling PLUMED</h1>
<p>Once configured, PLUMED can be compiled using the following command: </p><pre class="fragment">&gt; make -j 4
</pre><p> This will compile the entire code and produce a number of files in the 'src/lib' directory, including the executable 'src/lib/plumed'. When shared libraries are enabled, a shared libraries called 'src/lib/libKernel.so' should also be present. Notice that the extension could be '.dylib' on a Mac.</p>
<p>In case you want to run PLUMED <em>without installing it</em> (i.e. from the compilation directory), you can use the file 'sourceme.sh' that has been created by the configure script in the main PLUMED directory. This file can be "sourced" (presently only working for bash shell) if you want to use PLUMED <em>before installing it</em> (i.e. from the compilation directory). It is a good idea to source it now, so that you can play with the just compiled PLUMED: </p><pre class="fragment">&gt; source sourceme.sh
</pre><p>Now a "plumed" executable should be in your path. Try to type </p><pre class="fragment">&gt; plumed -h
</pre><dl class="section warning"><dt>Warning</dt><dd>If you are cross compiling, the plumed executable will not work. As a consequence, you won't be able to run regtests or compile the manual. This is not a problem.</dd></dl>
<p>You can also check if PLUMED is correctly compiled by performing our regression tests. Be warned that some of them fail because of the different numerical accuracy on different machines. As of version 2.4, in order to test the <code>plumed</code> executable that you just compiled (prior to installing it) you can use the following command </p><pre class="fragment">&gt; make check
</pre><p> On the other hand, in order to test the <code>plumed</code> executable that you just installed (see <a class="el" href="_installation.html#InstallingPlumed">Installing PLUMED</a>) you should type </p><pre class="fragment">&gt; make installcheck
</pre><p> In addition, similarly to previous versions of PLUMED, you can test the <code>plumed</code> executable that is in your current path with </p><pre class="fragment">&gt; cd regtest
&gt; make
</pre><p> You can check the exact version they will use by using the command </p><pre class="fragment">&gt; which plumed
</pre><p> Thus, you can easily run the test suite using a different version of PLUMED (maybe an earlier version that you already installed), just making sure that it can be found in the path. Clearly, if you test a given version of PLUMED with a test suite from a different version you can expect two possible kinds of innocuous errors:</p><ul>
<li>If <code>plumed</code> executable is older than the test suite, the tests might fail since they rely on some feature introduced in PLUMED in a newer version.</li>
<li>If <code>plumed</code> executable is newer than the test suite, the tests might fail since some non-backward compatible change was made in PLUMED. We try to keep the number of non-backward compatible changes small, but as you can see in the <a class="el" href="_change_log.html">Change Log</a> there are typically a few of them at every new major release.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Even though we regularly perform tests on <a href="http://travis-ci.org/plumed/plumed2">Travis-CI</a>, it is possible that aggressive optimization or even architecture dependent features trigger bugs that did not show up on travis. So please always perform the regtests when you install PLUMED.</dd></dl>
<p>Notice that the compiled executable, which now sits in 'src/lib/plumed', relies on other resource files present in the compilation directory. This directory should thus stay in the correct place. One should thus not rename or delete it. In fact the path to the PLUMED root directory is hard coded in the plumed executable as can be verified using </p><pre class="fragment">&gt; plumed info --root
</pre><p> In case you try to use the plumed executable without the compilation directory in place (e.g. you move away the src/lib/plumed static executable and delete or rename the compilation directory) PLUMED will not work correctly and will give you an error message </p><pre class="fragment">&gt; plumed help
ERROR: I cannot find /xxx/yyy/patches directory
</pre><p> You can force plumed to run anyway by using the option &ndash;standalone-executable: </p><pre class="fragment">&gt; plumed --standalone-executable help
</pre><p> Many features will not be available if you run in this way. However, this is currently the only way to use the PLUMED static executable on Windows.</p>
<h1><a class="anchor" id="InstallingPlumed"></a>
Installing PLUMED</h1>
<p>It is strongly suggested to install PLUMED in a predefined location. This is done using </p><pre class="fragment">&gt; make install
</pre><p> This will allow you to remove the original compilation directory, or to recompile a different PLUMED version in the same place.</p>
<p>To install PLUMED one should first decide the location: </p><pre class="fragment">&gt; ./configure --prefix=$HOME/opt
&gt; make
&gt; make install
</pre><p> As of PLUMED 2.5 you cannot anymore change the location during install. If you didn't specify the <code>--prefix</code> option during configure PLUMED will be installed in /usr/local. The install command should be executed with root permissions (e.g. "sudo make install") if you want to install PLUMED on a system directory.</p>
<p>Notice that upon installation PLUMED might need to relink a library. This was always true until version 2.1, but in version 2.2 libraries should only be relinked if one changes the install prefix during when typing <code>make install</code>. If root user does not have access to compilers, "sudo -E make install" might solve the issue.</p>
<p>Upon install, the executable is copied to $prefix/bin, libraries to $prefix/lib, include files to $prefix/include, and documentation to $prefix/shared/doc/plumed. Additionally, a directory $prefix/lib/plumed is created containing several other files, including patch files, object files (for static patches), etc. Notice also that these path can be further customized using standard autoconf directories (e.g. <code>./configure --bindir=/usr/bin64</code>).</p>
<p>One should then set the environment properly. We suggest to do it using the module framework (<a href="http://modules.sourceforge.net">http://modules.sourceforge.net</a>). An ad hoc generated module file for PLUMED can be found in $prefix/lib/plumed/src/lib/modulefile Just edit it as you wish and put it in your modulefile directory. This will also allow you to install multiple PLUMED versions on your machine and to switch among them. If you do not want to use modules, you can still have a look at the modulefile we did so as to know which environment variables should be set for PLUMED to work correctly.</p>
<p>If the environment is properly configured one should be able to do the following things:</p><ul>
<li>use the "plumed" executable from the command line. This is also possible before installing.</li>
<li>link against the PLUMED library using the "-lplumed" flag for the linker. This allows one to use PLUMED library in general purpose programs</li>
<li>use PLUMED internal functionality (C++ classes) including header files such as "#include &lt;plumed/tools/Vector.h&gt;". This is useful as it may be expedient to exploit the PLUMED library in general purpose programs</li>
</ul>
<p>As a final note, if you want to install several PLUMED versions without using modules then you should provide a different suffix and/or prefix at configure time: </p><pre class="fragment">&gt; ./configure prefix=$HOME/opt --program-suffix=_2.2 --program-prefix=mpi-
&gt; make install
</pre><p> This will install a plumed executable named "mpi-plumed_2.2". All the other files will be renamed similarly, e.g. the PLUMED library will be loaded with "-lmpi-plumed_2.2" and the PLUMED header files will be included with "#include &lt;mpi-plumed_2.2/tools/Vector.h&gt;". Notice that you can also use arbitrary scripts to edit the name of the executable with the option &ndash;program-transform-name=PROGRAM (see <a href="http://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Transformation-Examples.html#Transformation-Examples">autoconf documentation </a> for more info). These options are useful if you do not want to set up modules, but we believe that using modules as described above is more flexible.</p>
<h1><a class="anchor" id="Patching"></a>
Patching your MD code</h1>
<p>A growing number of MD codes can use PLUMED without any modification. If you are using one of these codes, refer to its manual to know how to activate PLUMED. In case your MD code is not supporting PLUMED already, you should modify it. We provide scripts to adjust some of the most popular MD codes so as to provide PLUMED support. At the present times we support patching the following list of codes:</p>
<ul>
<li>gromacs-2022-5</li>
<li>gromacs-2023-5</li>
<li>gromacs-2024-3</li>
<li>namd-2-12</li>
<li>namd-2-13</li>
<li>namd-2-14</li>
<li>qespresso-5-0-2</li>
<li>qespresso-6-2</li>
<li>qespresso-7-0</li>
<li>qespresso-7-2</li>
</ul>
<p>In the section <a class="el" href="_code_specific_notes.html">Code specific notes</a> you can find information specific for each MD code.</p>
<p>To patch your MD code, you should have already installed PLUMED properly. This is necessary as you need to have the command "plumed" in your execution path. As described above this executable will be in your paths if plumed was installed or if you have run sourceme.sh</p>
<p>Once you have a compiled and working version of plumed, follow these steps to add it to an MD code</p><ul>
<li>Configure and compile your MD engine (look for the instructions in its documentation).</li>
<li>Test if the MD code is working properly.</li>
<li>Go to the root directory for the source code of the MD engine.</li>
<li>Patch with PLUMED using: <pre class="fragment">&gt; plumed patch -p
</pre> The script will interactively ask which MD engine you are patching.</li>
<li>Once you have patched recompile the MD code (if dependencies are set up properly in the MD engine, only modified files will be recompiled)</li>
</ul>
<p>There are different options available when patching. You can check all of them using </p><pre class="fragment">&gt; plumed patch --help
</pre><p> Particularly interesting options include:</p><ul>
<li>&ndash;static just link PLUMED as a collection of object files. This is only suggested if for external reasons you absolutely need a static executable. Notice that with this setting it is often more complicated to configure properly the MD code, since all the libraries that PLUMED depends on should be properly specified. The <code>./configure</code> script does its best in this sense, but sometime it cannot solve the problem. Additionally, this patching mode has been reported not to work properly on OSX.</li>
<li>&ndash;shared (default) allows you to link PLUMED as a shared library. As a result when PLUMED is updated, there will be no need to recompile the MD code. This is way better than &ndash;static since the libraries that PLUMED depends on should be automatically linked. Notice that if you later remove the directory where PLUMED is installed also the MD code will not run anymore.</li>
<li>&ndash;runtime allows you to choose the location of the PLUMED library at runtime by setting the variable PLUMED_KERNEL. This is probably the most flexible option, and we encourage system administrators to use this option when installing PLUMED on shared facilities. Indeed, using this setting it will be possible to update separately the PLUMED library and the MD code, leaving to the user the possibility to combine different versions at will. We also recommend to use the provided modulefile (see above) to properly set the runtime environment.</li>
</ul>
<p>Notice that with PLUMED version &lt;2.5 there was no possibility to link PLUMED as a static library (something like 'libplumed.a'). However, starting with PLUMED 2.5, the <code>./configure</code> script will try to set up the system so that a <code>libplumed.a</code> file is produced. Patching an MD code with <code>--static</code> with try to link against this static library. Creation of the <code>libplumed.a</code> library can be avoided with <code>./configure --disable-static-archive</code>.</p>
<p>If your MD code is not supported, you may want to implement an interface for it. Refer to the <a href="../../developer-doc/html/index.html">developer manual </a>.</p>
<h1><a class="anchor" id="CrossCompiling"></a>
Cross compiling</h1>
<p>If you are compiling an executable from a different machine, then <code>plumed</code> executable will not be available in the compilation environment. This means that you won't be able to perform regtests on the machine nor to compile the manual. You can try to run the regtests on the computing nodes, but this might require some tweak since often machines where people do cross compiling have architectures with limited capabilities on the compute nodes. Also notice that many of the <code>plumed</code> options (e.g. patch) are implemented as shell scripts launched from within the <code>plumed</code> executable. If the compute nodes have some limitation (e.g. they do not allow to fork new processes) these options will not work. Anyway, the PLUMED library in combination with an MD software should work if both PLUMED and the MD software have been properly compiled.</p>
<p>Also notice that it will not be possible to use the command <code>plumed patch</code> on the machine where you are compiling. You should thus use <code>plumed-patch</code> instead of <code>plumed patch</code> (notice that it should be written as a single word).</p>
<p>Try e.g.: </p><pre class="fragment">&gt; plumed-patch --help
</pre><p> This script provides a "shell only" implementation of <code>plumed patch</code> that will skip the launch of the <code>plumed</code> executable.</p>
<p>Notice that other command line tools will be available in the directory <code>prefix/lib/progname/</code>. If configuring with default values this would be <code>/usr/local/lib/plumed/plumed-*</code>. These files are not included in the execution path (prefix/bin) to avoid clashes, but can be executed also when plumed is cross compiled and the main plumed executable cannot be launched.</p>
<h1><a class="anchor" id="Installation-macports"></a>
Installing PLUMED with MacPorts</h1>
<p>If you are using a Mac, notice that you can take advantage of a MacPorts package. Installing a working plumed should be as easy as:</p><ul>
<li>Install <a href="https://www.macports.org/">MacPorts</a></li>
<li>Type <code>sudo port install plumed</code></li>
</ul>
<p>Notice that plumed comes with many variants that can be inspected with the command </p><pre class="fragment">&gt; sudo port info plumed
</pre><p>Plumed uses variants to support different compilers. For instance, you can install plumed with mpich using </p><pre class="fragment">&gt; sudo port install plumed +mpich
</pre><p>Using more recent clang instead of native compilers is recommended so as to take advantage of openMP </p><pre class="fragment">&gt; sudo port install plumed +mpich +clang50
</pre><p>Notice that support for c++17 with gcc compilers is someway problematic within MacPorts due to impossibility to use the system c++ library. For this reason, only clang compilers are supported (see also <a href="https://github.com/macports/macports-ports/pull/1252">this discussion</a>).</p>
<p>Variants can be also used to compile with debug flags (<code>+debug</code>), to pick a linear algebra library (e.g. <code>+openblas</code>) and to enable all optional modules (<code>+allmodules</code>). Notice that the default variant installed with <code>sudo port install plumed</code> is shipped as a compiled binary, which is significantly faster to install.</p>
<p>In addition, we provide a developer version (typically: a later version not yet considered as stable) under the subport <code>plumed-devel</code> that can be installed with </p><pre class="fragment">&gt; sudo port install plumed-devel
</pre><p><code>plumed-devel</code> also supports the same variants as <code>plumed</code> in order to customize the compilation. <code>plumed-devel</code> and <code>plumed</code> cannot be installed at the same time.</p>
<p>It is also possible to install a plumed-patched version of gromacs. For instance, you can use the following command to install gromacs patched with plumed with clang-5.0 compiler and mpich: </p><pre class="fragment">&gt; sudo port install plumed +mpich +clang50
&gt; sudo port install gromacs-plumed +mpich +clang50
</pre><p>In case you want to combine gromacs with the unstable version of plumed, use this instead: </p><pre class="fragment">&gt; sudo port install plumed-devel +mpich +clang50
&gt; sudo port install gromacs-plumed +mpich +clang50
</pre><p>Notice that gromacs should be compiled using the same compiler variant as plumed (in this example <code>+mpich +clang50</code>). In case this is not true, compilation will fail.</p>
<p>Also notice that gromacs is patched with plumed in runtime mode but that the path of libplumedKernel.dylib in the MacPorts tree is hard coded. As a consequence:</p>
<ul>
<li>If gromacs is run with <code>PLUMED_KERNEL</code> environment variable unset (or set to empty), then the MacPorts plumed is used.</li>
<li>If gromacs is run with <code>PLUMED_KERNEL</code> environment variable pointing to another instance of the plumed library, the other instance is used.</li>
</ul>
<p>This is especially useful if you are developing PLUMED since you will be able to install gromacs once for all and combine it with your working version of PLUMED.</p>
<h1><a class="anchor" id="Installation-conda"></a>
Installing PLUMED with conda</h1>
<p>If you use the conda package manager you can install a pre-compiled PLUMED binary using the following command: </p><pre class="fragment">&gt; conda install -c conda-forge plumed
</pre><p> Similarly, the python wrappers can be installed with </p><pre class="fragment">&gt; conda install -c conda-forge py-plumed
</pre><p>These packages are part of <a href="https://anaconda.org/conda-forge">conda-forge</a> and as such should be binary compatible with other codes from the same distribution. Notice that it should also be possible to combine the installed plumed kernel with an MD code compiled outside of conda (or within a different conda environment) if plumed is linked in runtime mode. The only variable that you need to set in order to access to the installed plumed kernel is <code>PLUMED_KERNEL</code> (e.g., <code>export PLUMED_KERNEL=/conda/prefix/lib/libplumedKernel.so</code>).</p>
<p>Notice that binaries are only available for Linux and MacOS and that they have a limited number of features. In particular, they do not support MPI and do not include optional modules. However, they can be used to quickly install a working PLUMED version without the need to have a compiler.</p>
<p>Notice that there are additional conda packages on the <a href="https://anaconda.org/plumed/plumed">plumed</a> channel. Those packages are for testing only.</p>
<h1><a class="anchor" id="installingonacluster"></a>
Installing PLUMED on a cluster</h1>
<p>If you are installing PLUMED on a cluster and you want several users to take advantage of it consider the following suggestions.</p>
<p>First of all, we highly recommend using the module file that PLUMED provides to set up the environment. Just edit it as necessary to make it suitable for your environment.</p>
<p>Notice that PLUMED can take advantage of many additional features if specific libraries are available upon compiling it.</p>
<p>Try to patch all MD codes with the <code>--runtime</code> option. This will allow independent update of PLUMED and MD codes. Users will be able to combine any of the installed gromacs/amber/etc versions with any of the installed PLUMED versions. Notice that it is sometime claimed that statically linked codes are faster. In our experience, this is not true. In case you absolutely need a static executable, be ready to face non trivial linking issues. PLUMED is written in C++, thus required the appropriate C++ library to be linked, and might require additional libraries (e.g. libgsl).</p>
<p>Sometime we make small fixes on the patches. For this reason, keep track of which version of PLUMED you used to patch each of the MD code. Perhaps you can call the MD code modules with names such as <code>gromacs/4.6.7p1</code>, <code>gromacs/4.6.7p2</code> and write somewhere in the module file which version of PLUMED you used. Alternatively, call them something like <code>gromacs/4.6.7p2.2.0</code>. In this way, when we report a bug on the mailing list, users will know if the version they are using is affected by it.</p>
<p>Usually it is not necessary to install both a MPI and a non-MPI PLUMED version. PLUMED library only calls MPI functions when the MD code is compiled with MPI. PLUMED executable calls MPI functions only when it is invoked without <code>--no-mpi</code>. In many machines it is thus sufficient to run the plumed executable on the login node as </p><pre class="fragment">&gt; plumed --no-mpi
</pre><p> even though PLUMED was compiled with MPI and the login node does not support MPI. The only case where you might need two different PLUMED installation for compute and login node is when you are cross compiling.</p>
<p>PLUMED needs to be well optimized to run efficiently. If you need a single PLUMED binary to run efficiency on machines with different levels of hardware (e.g.: some of your workstations support AVX and some do not), with intel compiler you can use something like </p><pre class="fragment">&gt; ./configure CXX=mpicxx CXXFLAGS="-O3 -axSSE2,AVX"
</pre><p> It will take more time to compile but it will allow you to use a single module. Otherwise, you should install two PLUMED version with different optimization levels.</p>
<p>Using modules, it is not necessary to make the PLUMED module explicitly dependent on the used library. Imagine a scenario where you first installed a module <code>libgsl</code>, then load it while you compile PLUMED. If you provide the following option to configure <code>--enable-rpath</code>, the PLUMED executable and library will remember where libgsl is, without the need to load libgsl module at runtime. Notice that this trick often does not work for fundamental libraries such as C++ and MPI library. As a consequence, usually the PLUMED module should load the compiler and MPI modules.</p>
<dl class="section attention"><dt>Attention</dt><dd>In case you found out how to compile PLUMED on some fancy architecture please share your tricks! You can either post it in your blog, send it to the mailing list, or ask as to update this paragraph in the manual, we will be happy to do so.</dd></dl>
<h1><a class="anchor" id="installingpython"></a>
Installing Python wrappers</h1>
<p>As of PLUMED 2.5 it is possible to use the PLUMED library through Python wrappers. Notice that this is not something for end users but rather for developers. The interface is very similar to the one used in MD codes linked with PLUMED.</p>
<p>There are two ways to install Python wrappers.</p>
<h2><a class="anchor" id="installingpython-inside"></a>
Installing Python wrappers within PLUMED</h2>
<p>If <code>./configure</code> finds a <code>python</code> executable that also has the <code>cython</code> module available, Python wrappers will be installed within <code>/prefix/lib/plumed/python</code>. In order to access them, you should add this directory to the environment variable <code>PYTHONPATH</code>. Notice that if your python interpreter has a different name you might have to pass it to <code>./configure</code> with <code>PYTHON_BIN=python3.6</code>. The whole thing would then be:</p>
<div class="fragment"><div class="line">./configure PYTHON_BIN=python3.6 --prefix=$HOME/opt</div>
<div class="line">make &amp;&amp; make install</div>
<div class="line">export PYTHONPATH=&quot;$HOME/opt/lib/plumed/python:$PYTHONPATH&quot;</div>
<div class="line">python3.6</div>
<div class="line">&gt;&gt;&gt; import plumed</div>
</div><!-- fragment --><p>Notice that in this manner you will have to commit to a specific python version <b>before</b> installing PLUMED.</p>
<h2><a class="anchor" id="installingpython-outside"></a>
Installing Python wrappers outside PLUMED</h2>
<p>If you use multiple python versions, you might find it easier to install the Python wrappers separately from PLUMED. The simplest way is to do it with <code>pip</code>:</p>
<div class="fragment"><div class="line">pip3.6 install --user plumed</div>
</div><!-- fragment --><p>Here the <code>--user</code> flag allows you to install the packages on your home. Notice that you don't even need to download PLUMED in order to install the wrappers, but you will need PLUMED in order to use them. You can tell the wrappers where PLUMED is by setting the <code>PLUMED_KERNEL</code> environment variable:</p>
<div class="fragment"><div class="line">export PLUMED_KERNEL=$HOME/opt/lib/libplumedKernel.so</div>
<div class="line">python3.6</div>
<div class="line">&gt;&gt;&gt; import plumed</div>
</div><!-- fragment --><p>Notice that by installing the wrappers in this manner you will download those that are packaged on <a href="https://pypi.org/project/plumed/">Pypi</a>. If you want to install using pip the development version of the wrappers you should download the PLUMED repository and use the following commands:</p>
<div class="fragment"><div class="line">pip3.6 install --user cython # cython is required in this case</div>
<div class="line">cd plumed2/python</div>
<div class="line">make pip</div>
<div class="line">pip3.6 install --user .</div>
</div><!-- fragment --><p>If you want to install the development version it is recommended to use a virtualenv so that it will not interfere with the released packages.</p>
<h1><a class="anchor" id="installinghints"></a>
Other hints</h1>
<p>We here collect a list of suggestions that might be useful on particular machines.</p>
<ul>
<li>On Blue Gene Q (likely on AIX) the prelinking made with <code>ld -r</code> is not working properly. There is no easy way to detect this at configure time. If during <code>make</code> you receive an error in the form <pre class="fragment">ld: TOC section size exceeds 64k
</pre> please configure plumed again with the following flag <pre class="fragment">&gt; ./configure --disable-ld-r
</pre></li>
<li>On Cray machines, you might have to set the following environment variable before configuring and building both PLUMED and the MD code that you want to patch with PLUMED (kindly reported by Marco De La Pierre): <pre class="fragment">&gt; export CRAYPE_LINK_TYPE=dynamic
</pre></li>
<li>Intel MPI seems to require the flags <code>-lmpi_mt -mt_mpi</code> for compiling and linking and the flag <code>-DMPICH_IGNORE_CXX_SEEK</code> for compiling (kindly reported by Abhishek Acharya). You might want to try to configure using <pre class="fragment">&gt; ./configure LDFLAGS=-lmpi_mt CXXFLAGS="-DMPICH_IGNORE_CXX_SEEK -mt_mpi" STATIC_LIBS=-mt_mpi
</pre> Adding libraries to <code>STATIC_LIBS</code> uses them for all the linking steps, whereas those in <code>LIBS</code> are only used when linking the PLUMED kernel library. See more at <a href="https://groups.google.com/d/msgid/plumed-users/CAB1aw3y0m%3D5qwzsZY4ZB-aBevsL5iuS%3DmQuSWK_cw527zCMqzg%40mail.gmail.com?utm_medium=email&amp;utm_source=footer">this thread</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
<!--      -->
    <li class="footer">   <!--- Generated by -->
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
