<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: Reference for interfacing MD codes with PLUMED</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../user-doc/html/index.html"> <img src="developer-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Reference for interfacing MD codes with PLUMED </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Plumed.h and <a class="el" href="_plumed_8c.html">Plumed.c</a> contain the external plumed interface, which is used to integrate it with MD engines. This interface is very general, and is expected not to change across plumed versions. <a class="el" href="_plumed_8c.html">Plumed.c</a> also implements a dummy version of the interface, so as to allow a code to be fully linked even if the plumed library is not available yet. These files could be directly included in the official host MD distribution. In this manner, it will be sufficient to link the plumed library at link time (on all systems) or directly at runtime (on systems where dynamic loading is enabled) to include plumed features.</p>
<p>Notice that in PLUMED 2.5 this interface has been rewritten in order to allow more debugging features and a better behavior in multithread environments. The interface is almost perfectly backward compatible, although it implements a few additional functions. See more details below.</p>
<p>A further improvement has been made in PLUMED 2.8, where the interface has been modified to allow dynamic type checking. See more details below.</p>
<p>Why is <a class="el" href="_plumed_8c.html">Plumed.c</a> written in C and not C++? The reason is that the resulting Plumed.o needs to be linked with the host MD code immediately (whereas the rest of plumed could be linked a posteriori). Imagine the MD code is written in FORTRAN: when we link the Plumed.o file we would like not to need any C++ library linked. In this manner, we do not need to know which C++ compiler will be used to compile plumed. The C++ library is only linked to the "rest" of plumed, which actually uses it. Anyway, <a class="el" href="_plumed_8c.html">Plumed.c</a> is written in such a manner to allow its compilation also in C++ (C++ is a bit stricter than C). This will allow e.g. MD codes written in C++ to just incorporate <a class="el" href="_plumed_8c.html">Plumed.c</a> (maybe renamed into <a class="el" href="_plumed_8cpp.html">Plumed.cpp</a>), without the need of configuring a plain C compiler.</p>
<p>Plumed interface can be used from C, C++ and FORTRAN. Everything concerning plumed is hidden inside a single object type, which is described in C by a structure (struct <a class="el" href="structplumed.html">plumed</a>), in C++ by a class (<a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">PLMD::Plumed</a>) and in FORTRAN by a fixed-length string (CHARACTER(LEN=32)). Obviously C++ can use both struct and class interfaces, but the second should be preferred since it will automatically take care of objects constructions and destructions. The reference interface is the C one, whereas FORTRAN and C++ interfaces are implemented as wrappers around it. In the C++ interface, all the routines are implemented as methods of <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">PLMD::Plumed</a>. In the C and FORTRAN interfaces, all the routines are named plumed_*, to avoid potential name clashes. Notice that the entire plumed library is implemented in C++, and it is hidden inside the <a class="el" href="namespace_p_l_m_d.html">PLMD</a> namespace.</p>
<p>Handlers to the plumed object can be converted among different representations, to allow inter-operability among languages. In C, there are tools to convert to/from FORTRAN, whereas in C++ there are tools to convert to/from FORTRAN and C.</p>
<p>These handlers only contain a pointer to the real structure, so that when a plumed object is brought from one language to another, it brings a reference to the same environment.</p>
<p>Moreover, to simplify life in all cases where a single Plumed object is required for the entire simulation (which covers many of the practical applications with conventional MD codes) it is possible to take advantage of a global interface, which is implicitly referring to a unique global instance. The global object should still be initialized and finalized properly. This global object is obviously not usable in a multithread context. In addition, it is difficult to use it in an exception-safe manner, so its usage in C++ is allowed but discouraged.</p>
<p>As of PLUMED 2.5, the interface contains a reference counter that allows for a better control of plumed initializations and deallocations. This is particularly useful for the C++ interface that now behaves similarly to a primitive shared pointer and can be thus copied. In other languages, to use the reference counter correctly it is sufficient to remember the following rule: for any <code>plumed_create*</code> call, there should be a corresponding <code>plumed_finalize</code> call. More examples can be found below.</p>
<p>Notice that up to PLUMED 2.8 the reference counter was not thread safe. This is fixed when using PLUMED&gt;=2.9 wrappers with a PLUMED&gt;=2.9 kernel.</p>
<p>The basic method to send a message to plumed is </p><pre class="fragment">  (C) plumed_cmd
  (C++) PLMD::Plumed::cmd
  (FORTRAN)  PLUMED_F_CMD
</pre><p>To initialize a plumed object, use: </p><pre class="fragment">  (C)        plumed_create
  (C++)      (constructor of PLMD::Plumed)
  (FORTRAN)  PLUMED_F_CREATE
</pre><p>As of PLUMED 2.5, you can also initialize a plumed object using the following functions, that load a specific kernel. The function plumed_create_dlopen2 allows to specify options for dlopen. The C++ version accepts an optional argument to this aim. </p><pre class="fragment">  (C)        plumed_create_dlopen or plumed_create_dlopen2
  (C++)      PLMD::Plumed::dlopen
  (FORTRAN)  PLUMED_F_CREATE_DLOPEN
</pre><p>As of PLUMED 2.8, you can also initialize a plumed object using the following function, that loads a kernel from an already loaded shared library. It accepts a handler returned by <code>dlopen</code>: </p><pre class="fragment">  (C)        plumed_create_dlsym
  (C++)      PLMD::Plumed::dlsym
  (FORTRAN not allowed)
</pre><p>To finalize a plumed object, use </p><pre class="fragment">  (C)        plumed_finalize
  (C++)      (destructor of PLMD::Plumed)
  (FORTRAN)  PLUMED_F_FINALIZE
</pre><p>To access to the global-object, use </p><pre class="fragment">  (C)        plumed_gcreate, plumed_gfinalize, plumed_gcmd
  (C++)      PLMD::Plumed::gcreate, PLMD::Plumed::gfinalize, PLMD::Plumed::gcmd
  (FORTRAN)  PLUMED_F_GCREATE, PLUMED_F_GFINALIZE, PLUMED_F_GCMD
</pre><p>To check if the global object has been initialized, use </p><pre class="fragment">  (C)        plumed_ginitialized
  (C++)      PLMD::Plumed::ginitialized
  (FORTRAN)  PLUMED_F_GINITIALIZED
</pre><p>Notice that when using runtime binding the plumed library might be not available. In this case, plumed_create (and plumed_gcreate) will still succeed, but a subsequent call to plumed_cmd (or plumed_gcmd) would exit. In order to avoid this unpleasant situation you have two options.</p>
<p>First, you can check if plumed library is available before actually creating an object using this function: </p><pre class="fragment">  (C)        plumed_installed
  (C++)      PLMD::Plumed::installed
  (FORTRAN)  PLUMED_F_INSTALLED
</pre><p>Alternatively, as of PLUMED 2.5, you can interrogate the just created plumed object using the following function: </p><pre class="fragment">  (C)        plumed_valid
  (C++)      PLMD::Plumed::valid
  (FORTRAN)  PLUMED_F_VALID
</pre><p>If you want to create on purpose an invalid Plumed object (useful in C++ to postpone the loading of the library) you can use <code>Plumed p(Plumed::makeInvalid());</code>.</p>
<p>To know if the global object is valid instead you should use the following function: </p><pre class="fragment">  (C)        plumed_gvalid
  (C++)      PLMD::Plumed::gvalid
  (FORTRAN)  PLUMED_F_GVALID
</pre><p>To convert handlers between different languages, use </p><pre class="fragment">  (C)        plumed_c2f                 (C to FORTRAN)
  (C)        plumed_f2c                 (FORTRAN to C)
  (C++)      Plumed(plumed) constructor (C to C++)
  (C++)      operator plumed() cast     (C++ to C)
  (C++)      Plumed(char*)  constructor (FORTRAN to C++)
  (C++)      toFortran(char*)           (C++ to FORTRAN)
</pre><p>As of PLUMED 2.5, when using C or C++ we allow a user to explicitly store a plumed object as a void pointer (indeed: that's the only thing contained in a plumed object). This might be useful in case you do not want to include the Plumed.h header in some of your headers. In order to convert to/from void pointers you can use the following functions </p><pre class="fragment">  (C)        plumed_v2c                 (void* to C)
  (C)        plumed_c2v                 (C to void*)
  (C++)      Plumed(void*) constructor  (void* to C++)
  (C++)      toVoid()                   (C++ to void*)
</pre><p> Using the functions above is much safer than accessing directly the pointer contained in the <a class="el" href="structplumed.html">plumed</a> struct since, when compiling with debug options, it will check if the void pointer actually points to a plumed object.</p>
<p>As of PLUMED 2.5, we added a reference count. It is in practice possible to create multiple <code>plumed</code> objects that refer to the same environment. This is done using the following functions </p><pre class="fragment">  (C)        plumed_create_reference     (from a C object)
  (C)        plumed_create_reference_f   (from a FORTRAN object)
  (C)        plumed_create_reference_v   (from a void pointer)
  (FORTRAN)  plumed_f_create_reference   (from a FORTRAN object)
</pre><p> In C++ references are managed automatically by constructors and destructor. In addition, you can manually manage them (with care!) using incref() and decref().</p>
<p>The interface of the FORTRAN functions is very similar to that of the C functions and is listed below:</p>
<pre class="fragment">  FORTRAN interface
    SUBROUTINE PLUMED_F_CREATE(p)
      CHARACTER(LEN=32), INTENT(OUT)   :: p
    SUBROUTINE PLUMED_F_CREATE_DLOPEN(p,path)
      CHARACTER(LEN=32), INTENT(OUT)   :: p
      CHARACTER(LEN=*),  INTENT(IN)    :: path
    SUBROUTINE PLUMED_F_CREATE_REFERENCE(p,r)
      CHARACTER(LEN=32), INTENT(OUT)   :: p
      CHARACTER(LEN=32), INTENT(IN)    :: r
    SUBROUTINE PLUMED_F_CREATE_INVALID(p)
      CHARACTER(LEN=32), INTENT(OUT)   :: p
    SUBROUTINE PLUMED_F_CMD(p,key,val)
      CHARACTER(LEN=32), INTENT(IN)    :: p
      CHARACTER(LEN=*),  INTENT(IN)    :: key
      UNSPECIFIED_TYPE,  INTENT(INOUT) :: val(*)
    SUBROUTINE PLUMED_F_FINALIZE(p)
      CHARACTER(LEN=32), INTENT(IN)    :: p
    SUBROUTINE PLUMED_F_INSTALLED(i)
      INTEGER,           INTENT(OUT)   :: i
    SUBROUTINE PLUMED_F_VALID(p,i)
      CHARACTER(LEN=32), INTENT(IN)    :: p
      INTEGER,           INTENT(OUT)   :: i
    SUBROUTINE PLUMED_F_USE_COUNT(p,i)
      CHARACTER(LEN=32), INTENT(IN)    :: p
      INTEGER,           INTENT(OUT)   :: i
    SUBROUTINE PLUMED_F_GLOBAL(p)
      CHARACTER(LEN=32), INTENT(OUT)   :: p
    SUBROUTINE PLUMED_F_GINITIALIZED(i)
      INTEGER,           INTENT(OUT)   :: i
    SUBROUTINE PLUMED_F_GCREATE()
    SUBROUTINE PLUMED_F_GCMD(key,val)
      CHARACTER(LEN=*), INTENT(IN)     :: key
      UNSPECIFIED_TYPE, INTENT(INOUT)  :: val(*)
    SUBROUTINE PLUMED_F_GFINALIZE()
    SUBROUTINE PLUMED_F_GVALID(i)
      INTEGER,           INTENT(OUT)   :: i
</pre><p>Almost all C functions have a corresponding FORTRAN function. As a simple mnemonic, if you know the name of the C function you can obtain the corresponding FORTRAN subroutine by adding <code>F_</code> after the <code>PLUMED_</code> prefix. In addition, all <code>plumed</code> objects are replaced by <code>CHARACTER(LEN=32)</code> objects holding the same information. These pointers basically contain a text representation of the stored pointer, that is suitable to be contained in a string. Finally, whenever a C function returns a value, the corresponding FORTRAN subroutine will have an additional <code>INTENT(OUT)</code> parameter passed as the its last argument.</p>
<p>When you compile the FORTRAN interface, wrapper functions are added with several possible name manglings, so you should not experience problems linking the plumed library with a FORTRAN file.</p>
<h1><a class="anchor" id="ReferencePlumedH-exceptions"></a>
Error handling</h1>
<p>In case an error is detected by PLUMED, either because of some user error, some internal bug, or some mistake in using the library, an exception will be thrown. The behavior is different depending if you use PLUMED from C/FORTRAN or from C++.</p>
<p>First of all, notice that access to PLUMED goes through three functions:</p><ul>
<li>plumed_create: this, as of PLUMED 2.5, is guaranteed not to throw any exception. If there is a problem, it will just return a plumed object containing a NULL pointer</li>
<li>plumed_cmd: this function might throw exceptions.</li>
<li>plumed_finalize: this is a destructor and is guaranteed not to throw any exception.</li>
</ul>
<p>The following discussion concerns all the exceptions thrown by plumed_cmd.</p>
<p>If you use C/FORTRAN, you will basically have no way to intercept the exception and the program will just terminate.</p>
<p>If you use C++ and you are calling the C++ interface (e.g. Plumed::cmd), as of PLUMED 2.5 we implemented a complete remapping of the exceptions thrown by PLUMED. This solves both the problems mentioned above. In particular:</p><ul>
<li>Instead of throwing an exception, PLUMED will return (using a <a class="el" href="structplumed__nothrow__handler.html">plumed_nothrow_handler</a>) the details about the occurred error.</li>
<li>An equivalent exception will be thrown within the inline PLUMED interface compiled with your MD code.</li>
</ul>
<p>As a consequence, you will be able to combine different compilers and avoid stack unwinding in the C layer.</p>
<p>If you use C++ but you are calling the C interface (e.g. <a class="el" href="structplumed.html#a73ba19363c1bd3bd76045b9a515181ad">plumed_cmd</a>), then you might be able to catch the exceptions thrown by PLUMED. Notice that all the exceptions thrown by PLUMED inherit from std::exception, so you might want to catch it by reference. By default, as of PLUMED 2.8 <a class="el" href="structplumed.html#a73ba19363c1bd3bd76045b9a515181ad">plumed_cmd</a> is redefined as a macro and directly calls the Plumed::cmd interface, and thus behaves in an equivalent manner. With previous versions of this header one could have encountered problems with stack unwinding performed during exception handling in the C layer.</p>
<p>Notice that, even if you use Plumed::cmd, if you are loading a kernel &lt;=2.4 any exception generated by PLUMED will leak through the C layer. This might lead to undefined behavior. If you are lucky (with some compiler it works!) and the exception arrives to C, PLUMED will catch it and rethrow it as it would do if you were using a kernel &gt;=2.5.</p>
<p>The remapping of exceptions takes care of all the standard C++ exceptions plus all the exceptions raised within PLUMED. Unexpected exceptions that are derived from std::exception will be rethrown as std::exception. Notice that this implies some loss of information, since the original exception might have been of a different type. However, it also implies that the virtual table of the original exception won't be needed anymore. This allows to completely decouple the MD code from the PLUMED library.</p>
<h1><a class="anchor" id="ReferencePlumedH-typesafe"></a>
Typesafe interface</h1>
<p>Starting with PLUMED 2.8, the <code>cmd</code> function of the C++ interface, and the similar function <code>gcmd</code>, can be called with several interfaces and can perform a typechecking on the passed argument. In particular, the following forms are now possible: </p><pre class="fragment">  cmd("string",value);        // by value
  cmd("string",&amp;value);       // by pointer
  cmd("string",&amp;value,nelem); // by pointer, specifying the number of elements of the passed array
  cmd("string",&amp;value,shape); // by pointer, specifying the shape of the passed array
\endverbati
  The `nelem` and `shape` arguments are used by PLUMED to check that the user
  provided enough elements. If nelem is provided, the check is done on the flatten array, whereas if shape
  is passed a more thorough check is performed controlling each of the dimensions of the array.
  In addition to this, the type of the pointer (or of the value) is checked at runtime.

  All these checks are only implemented if the PLUMED library is recent (&gt;=2.8). However, it will still be
  possible to load at runtime an older PLUMED library (&lt;=2.7). For this reason, it is still compulsory
  to pass the correct types to the `cmd` function, also when the argument is passed by value.
  Type conversions are only performed between pointers and only in ways compatible with
  what is allowed in C++ (e.g., `const void*` cannot be converted to `void*`, but `void*` can
  be converted to `const void*`).

  Type checks can be disabled by setting `export PLUMED_TYPESAFE_IGNORE=yes` at runtime.

  Typechecks are also enabled in the C interface (plumed_cmd). This function is replaced with a macro by default.
  In particular:
  - If the C interface is used in C++ code, it calls the C++ interface. Can be disabled with `-D__PLUMED_WRAPPER_CXX_BIND_C=0`.
  - If the C interface is used in C code and compiled with a C11 compiler, it uses _Generic to pass type information.
    Can be disabled using `-D__PLUMED_WRAPPER_C_TYPESAFE=0`.

\section ReferencePlumedH-2-5 New in PLUMED 2.5

  The wrappers in PLUMED 2.5 have been completely rewritten with several improvements.
  The interface is almost perfectly backward compatible, although the behavior of C++ constructors
  has been modified slightly.
  In addition, a few new functions are introduced (explicitly marked in the documentation).
  As a consequence, if your code uses some of the new functions, you will not be able
  to link it directly with an older PLUMED library (though you will still be able to load
  an older PLUMED library at runtime). In addition, the reference counter changes slightly
  the behavior of the C++ methods used to interoperate with C and FORTRAN.

  An important novelty is in the way the runtime loader is implemented.
  In particular, the loader works also if the symbols of the main executable are not exported.
  The proper functions from the kernel are indeed searched explicitly now using `dlsym`.

  Some additional features can be enabled using suitable environment variables. In particular:
  - `PLUMED_LOAD_DEBUG` can be set to report more information about the loading process.
  - `PLUMED_LOAD_NAMESPACE` can be set to choose in which namespace PLUMED is loaded when using runtime
    loading. As of version 2.10, PLUMED is loaded with RTLD_LOCAL by default. The behavior can be reverted
    by exporting `PLUMED_LOAD_NAMESPACE=GLOBAL`. The default setting facilitates loading multiple
    versions of PLUMED simultaneously.
  - `PLUMED_LOAD_NODEEPBIND` can be set to load the PLUMED kernel in not-deepbind mode. Deepbind
    mode implies that the symbols defined in the library are preferred to other symbols with the same name.
    Only works on systems supporting `RTLD_DEEPBIND` and is mostly for debugging purposes.

  Another difference is that the implementation of the wrappers is now completely contained in the `Plumed.h`
  file. You can see that the `Plumed.c` is much simpler now and just includes `Plumed.h`. With a similar
  procedure you could compile the wrappers directly into your code making it unnecessary to link
  the libplumedWrapper.a library. The corresponding macros are still subject to change and are not documented here.

  As written above, the plumed object now implements a reference counter.  Consider the following example
\verbatim
  plumed p=plumed_create();
  plumed_cmd(p,"init",NULL);
  plumed q=plumed_create_reference(p);
  plumed_finalize(p);
// at this stage, object q still exists
  plumed_cmd(q,"whatever",NULL);
  plumed_finalize(q);
// now plumed has been really finalized
</pre><p>In other words, every <a class="el" href="structplumed.html#ad2c7269d82d4bfecb0118375ecd12177">plumed_create</a>, <a class="el" href="structplumed.html#ab309276b0175e72fd77ff41784cdec31">plumed_create_dlopen</a>, <a class="el" href="structplumed.html#abe6cabd5ea7a88735ec80d4d5593540f">plumed_create_reference</a>, <a class="el" href="structplumed.html#a1fe744b1fd26c36cc8a1d36850821c4d">plumed_create_reference_f</a>, and <a class="el" href="structplumed.html#ac3cb48b62136702e92ff7ae2d0862ea7">plumed_create_reference_v</a> call must be matched by a <a class="el" href="structplumed.html#aa799d9bd217f790e8fe1a2d29b5cf3ff">plumed_finalize</a>. Notice that in C++ whenever an object goes out of scope the reference counter will be decreased. In addition, consider that conversion from C/FORTRAN/void* to C++ implies calling a C++ constructor, that is increases the number of references by one. Converting from C++ to C/FORTRAN/void* instead does not call any constructor, that is the number of references is unchanged.</p>
<p>The change in the behavior of C++ constructors means that the following code will behave in a backward incompatible manner: </p><pre class="fragment">  plumed p=plumed_create();
  plumed_cmd(p,"init",NULL);
  Plumed q(p);
  plumed_finalize(p);
// at this stage, object q still exists with PLUMED 2.5
// on the other hand, with PLUMED 2.4 object q refers to an
// already finalized object
  q.cmd("whatever",NULL);
</pre><p>Another difference is that the value of the variable <code>PLUMED_KERNEL</code> is read every time a new plumed object is instantiated. So, you might even use it to load different plumed versions simultaneously, although the preferred way to do this is using the function <a class="el" href="structplumed.html#ab309276b0175e72fd77ff41784cdec31">plumed_create_dlopen</a>. Notice that if you want to load multiple versions simultaneously you should load them in a local namespace. <a class="el" href="structplumed.html#ab309276b0175e72fd77ff41784cdec31">plumed_create_dlopen</a> does it automatically, whereas loading through env var <code>PLUMED_KERNEL</code> only does it if you also set env var <code>PLUMED_NAMESPACE=LOCAL</code>.</p>
<p>Finally, a few functions have been added, namely:</p><ul>
<li>Functions to find if a plumed object is valid (<a class="el" href="structplumed.html#a150967a80004deff89723c6d6ddc2c6c">plumed_valid()</a>, <a class="el" href="structplumed.html#a5c0e9b1cd4c2d0761aeb1e82950e7d63">plumed_gvalid()</a>, <a class="el" href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">PLMD::Plumed::valid()</a>, and <a class="el" href="class_p_l_m_d_1_1_plumed.html#ab914eefe610aed5b41db61848f3191db">PLMD::Plumed::gvalid()</a>).</li>
<li>Functions to create a plumed object based on the path of a specific kernel (<a class="el" href="structplumed.html#ab309276b0175e72fd77ff41784cdec31">plumed_create_dlopen()</a> and <a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1fa52234845e6aa67e50211f96e6dee">PLMD::Plumed::dlopen()</a>).</li>
<li>Functions to create a plumed object referencing to another one, implementing a reference counter (<a class="el" href="structplumed.html#abe6cabd5ea7a88735ec80d4d5593540f">plumed_create_reference()</a>, <a class="el" href="structplumed.html#ac3cb48b62136702e92ff7ae2d0862ea7">plumed_create_reference_v()</a>, <a class="el" href="structplumed.html#a1fe744b1fd26c36cc8a1d36850821c4d">plumed_create_reference_f()</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<table align="center" frame="void" width="98%" cellpadding="2%">
<tr><td align="left" valign="center"> 
Hosted by GitHub &nbsp;
<a href="http://github.com"><img src="octocat.png" width="88" height="66"  alt="GitHub Logo" /></a>
<!--Generated by  &#160; --> <a href="http://www.doxygen.org/index.html">
</td><td width=90% align="right">
<img class="footer" src="doxygen.png" alt="doxygen" align="right"/>
</a> 1.8.17
</td> </tr> 
</table>
</small></address>
</body>
</html>
