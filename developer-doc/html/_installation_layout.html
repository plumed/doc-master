<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: Installation Layout</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../user-doc/html/index.html"> <img src="developer-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Installation Layout </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>I write here some notes related to how plumed is installed.</p>
<p>As a first notice, plumed package is mostly designed to make these tools available:</p><ul>
<li>a <code>plumed</code> executable, that can be used to launch command line tools.</li>
<li>a <code>libplumed.so</code> library, that can be linked to an externally supplied MD code.</li>
</ul>
<p>These are the main entry points to plumed, but they require several other resources to be properly located so as to work. Moreover, plumed is designed to be usable both when "just compiled" (so as to allow for fast development) and when properly installed. This results in the non trivial problem of knowing where the required resources are located.</p>
<p>Additionally, we provide shell-only alternatives to command line tools. E.g., to use <code>plumed patch</code> in a cross compiled environment, one can call <code>plumed-patch</code> which does the same but bypass the <code>plumed</code> executable and directly executes as a bash script.</p>
<p>As a result, plumed routines and scripts can be entered in three ways:</p><ul>
<li>calling <code>plumed</code> from the command line.</li>
<li>calling <code>plumed-patch</code> from the command line.</li>
<li>entering the shared library from another code (typically an MD code).</li>
</ul>
<p>This is achieved in the following way:</p><ul>
<li><code>plumed-*</code> scripts contains hardcoded environment variables pointing at the correct paths when they are launched.</li>
<li><code>plumed</code> executable and <code>libplumed.so</code> have access to methods (in the config namespace) to access to the paths and locate resources.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Since paths are hardcoded, plumed executable and library are de facto not relocatable. It is however possible to use them after relocation provided that some environment variables are set as discussed below.</dd></dl>
<p>As an example, the <code>PLUMED_ROOT</code> variable is defined to tell to the plumed scripts where to find most of the plumed-related files. Similarly, from C++ you can use <a class="el" href="namespace_p_l_m_d_1_1config.html#ac912fda233a0fc65f8ffa814b9af13b1">config::getPlumedRoot()</a> to retrieve the same path.</p>
<p>When a plumed command line tool implemented as script is invoked by the plumed executable, thus transferring the control from C++ to an external script, the environment should be consistently set. This is done in method <a class="el" href="namespace_p_l_m_d_1_1config.html#a85049ba946c77d09993e858d046d198a">config::getEnvCommand()</a> which builds a string in the form <code>env PLUMED_ROOT=/path env PLUMED_INCLUDEDIR=/path</code> etc. In this ways, the scripts are run in an environment with the correct settings.</p>
<p>The following paths need to be set for plumed to work properly. Here they are listed together with the name of the corresponding environment variables (that can be used in plumed scripts) and the method that can be used to retrieve them from C++ code.</p><ul>
<li>Root of plumed: <code>$PLUMED_ROOT</code> <a class="el" href="namespace_p_l_m_d_1_1config.html#ac912fda233a0fc65f8ffa814b9af13b1">config::getPlumedRoot()</a></li>
<li>Path to include files: <code>$PLUMED_INCLUDEDIR</code> <a class="el" href="namespace_p_l_m_d_1_1config.html#a66757361f249fd1a951ff1ff067d3ae7">config::getPlumedIncludedir()</a></li>
<li>Path to html files: <code>$PLUMED_HTMLDIR</code> <a class="el" href="namespace_p_l_m_d_1_1config.html#aac17119d37fbb1d6b992d34f6c2f19f3">config::getPlumedHtmldir()</a></li>
<li>Name of plumed program: <code>$PLUMED_PROGRAM_NAME</code> <a class="el" href="namespace_p_l_m_d_1_1config.html#a6e5fb918a02168340970553d086131f6">config::getPlumedProgramName()</a></li>
</ul>
<p>When using plumed from its build directory (without installing it) these paths will be set to the value reported below:</p><ul>
<li><code>PLUMED_ROOT=/build/directory</code></li>
<li><code>PLUMED_INCLUDEDIR=$PLUMED_ROOT/src/include</code> (this works thanks to a symlink of <code>/build/directory/src</code> to <code>/build/directory/src/include/plumed</code>)</li>
<li><code>PLUMED_HTMLDIR=$PLUMED_ROOT</code></li>
<li><code>PLUMED_PROGRAM_NAME=plumed</code></li>
</ul>
<p>These paths are hardcoded in <code>plumed</code> executable and in <code>plumed-*</code> scripts when they are compiled. Notice that it is possible to set the <code>PLUMED_ROOT</code> variable before calling plumed overriding the hard code values. E.g., you can compile plumed in directory <code>/build/directory1</code>, move it to <code>/build/directory2</code>, and launch it with <code>PLUMED_ROOT=/build/directory2 /build/directory2/src/lib/plumed</code>. Notice however that although plumed will find all the required resources in this way, it might not be possible to perform some task such as patching MD code. Also notice that since the structure of the build directory is fixed the <code>PLUMED_ROOT</code> variable is sufficient to reconstruct the other paths.</p>
<p>When using plumed after it has been installed, these paths will be set to the value reported below:</p><ul>
<li><code>PLUMED_ROOT=/usr/local/lib/plumed</code></li>
<li><code>PLUMED_INCLUDEDIR=/usr/local/include</code></li>
<li><code>PLUMED_HTMLDIR=/usr/local/share/doc/plumed</code></li>
<li><code>PLUMED_PROGRAM_NAME=plumed</code></li>
</ul>
<p>These paths are hardcoded in <code>plumed</code> executable and in <code>plumed-*</code> scripts when they are installed. Notice that these value can be customized at configure step using standard arguments to ./configure. When using an installed copy of plumed one can override the hard code values by setting the variables <code>PLUMED_ROOT</code>, <code>PLUMED_INCLUDEDIR</code> ,<code>PLUMED_HTMLDIR</code>, and <code>PLUMED_PROGRAM_NAME</code> before launching plumed.</p>
<p>Notice that to enforce a consistent behavior of scripts and plumed executable the same logic needed to be implemented twice. One implementation is found in the <code>src/config/Config.inc.in</code> file, another implementation is prependend to the installed scripts by the <code>src/lib/Makefile</code>.</p>
<p>Also consider that environment is inherited by subprocesses. That means that if you want to launch another plumed version from a plumed script (crazy idea, perhaps nobody will ever do it) you should unexport the relevant environment variables so that the second plumed executable will find its paths correctly.</p>
<h1><a class="anchor" id="InstallationLayout-files"></a>
Installed files</h1>
<p>I here describe what's the content of the most important files installed by plumed.</p>
<p><code>/usr/local/bin/plumed</code>: this is a static executable that can be used to launch plumed. It is typically used to launch a command line tool (e.g. <code>plumed sum_hills</code>). Notice that some command line tools are actually implemented as bash scripts (e.g. <code>plumed patch</code>). Those scripts are located in <code>$PLUMED_ROOT/scripts/</code> with an extra <code>.sh</code> suffix. E.g. the <code>plumed patch</code> command will set properly the environment then call <code>$PLUMED_ROOT/scripts/patch.sh</code>.</p>
<p><code>/usr/local/lib/libplumed.so</code>: this is a library containing all the plumed routines. Notice that <code>/usr/local/bin/plumed</code> described above is equal to the combination of <code>/usr/local/lib/libplumed.so</code> with a single object file compiled from <code>buildroot/src/main/main.cpp</code>.</p>
<p><code>/usr/local/lib/libplumedKernel.so</code>: this is a library containing almost all the plumed routines, with the exception of those called from MD engines. Notice that <code>/usr/local/lib/libplumed.so</code> described above is equal to the combination of <code>/usr/local/lib/libplumedKernel.so</code> with a single object file compiled from <code>buildroot/src/wrapper/PlumedStatic.cpp</code></p>
<p><code>/usr/local/lib/libplumedWrapper.a</code>: this is a static library containing exclusively the object file compiled from <code>buildroot/src/wrapper/Plumed.cpp</code></p>
<p>To summarize:</p><ul>
<li><code>bin/plumed</code> = <code>buildroot/src/main/main.cpp</code> + <code>lib/libplumed.so</code></li>
<li><code>lib/libplumed.so</code> = <code>buildroot/src/wrapper/PlumedStatic.cpp</code> + <code>lib/libplumedKernel.so</code></li>
<li><code>lib/libplumedWrapper.a</code> = <code>buildroot/src/wrapper/Plumed.cpp</code></li>
</ul>
<p>The logic of this subdivision is that it is possible to either link the MD code to <code>/usr/local/lib/libplumed.so</code> or to link it to a single object file (the one compiled from <code>buildroot/src/wrapper/Plumed.c</code> or the installed <code>libplumedWrapper.a</code>) so as to allow linking at run time an a posteriori chosen plumed library. This is the trick behind the <code>--runtime</code> patching procedure.</p>
<p>Notice that the only differences between <code>buildroot/src/wrapper/PlumedStatic.cpp</code> and <code>buildroot/src/wrapper/Plumed.c</code> are that runtime binding is disabled for the first one and that the second one is compiled as plain C. This makes it less likely to do mistakes when linking lib/libplumed.so (by unintentionally using a different version of plumed), and makes C++ library unnecessary if an external code is only interesting in linking the PLUMED wrappers in <code>buildroot/src/wrapper/Plumed.c</code> or in <code>libplumedWrapper.a</code>.</p>
<p>We can then dissect more the content of <code>/usr/local/lib/libplumedKernel.so</code>. This library puts together a large list of object files. The same object files will be located after install in <code>/usr/local/lib/plumed/obj/k*.o</code>. I use a wildcard here because these might be many files (named <code>k0.o</code>, 'k1.o', etc) or a single <code>kernel.o</code> file (when <code>ld -r -o</code> can be used to merge them together). The reason why we store object files in the installed directory is that this is the most portable way to link statically C++ objects to another executable. Indeed, merging them in a single .a file (such as libplumed.a) would require this library to be linked with special flags so as to allow dropping all the static constructors. Whereas the special flags could be found by autoconf, it seems simpler to directly link <code>/usr/local/lib/plumed/obj/k*.o</code>.</p>
<p>Also notice that this library changes slighlty in the installed version (<code>/usr/local/lib/libplumedKernel.so</code>) and in the pre-install version (<code>buildroot/src/lib/libplumedKernel.so</code>). Indeed, whereas the former include the object file from <code>buildroot/src/config/ConfigInstall.cpp</code> the latter includes the object file from <code>buildroot/src/config/Config.cpp</code>. This object file is the one containing the hardcoded paths discussed above, and thus should include different strings in the installed and pre-install versions.</p>
<dl class="section note"><dt>Note</dt><dd>New in PLUMED v2.5, the <code>./configure</code> script will check if it is possible to build a <code>/usr/local/lib/libplumed.a</code> library. This library contains basically <code>buildroot/src/wrapper/PlumedStatic.cpp</code> and the single object obtained merging all the objects in the kernel. When this library is linked, if at least one of the functions in the wrappers is called (e.g. <code>plumed_cmd</code>) then all the objects are pulled in. In principle, this should solve the problem with C++ static constructors. This feature can be disabled with <code>--disable-static-archive</code>.</dd></dl>
<h1><a class="anchor" id="InstallationLayout-installation"></a>
Installation procedure</h1>
<p>When <code>make</code> is invoked, several things are performed. First, all the source files are compiled. The <code>plumed</code> executable and the library files are put in <code>buildroot/src/lib</code>. Then, the "to be installed" versions of the executable and library files are produced and located in <code>buildroot/src/lib/install</code>. These are different from those located in <code>buildroot/src/lib</code> in that they include the <code>buildroot/src/config/ConfigInstall.o</code> object so as to hardcode the proper paths.</p>
<p>When <code>make install</code> is invoked, the makefile checks if the objects in <code>buildroot/src/lib/install</code> should be updated and, if necessary, recompiles them. If not, it just copies all the material in place. Notice that all the resulting files are real files (no symlinks). This is a novelty with respect to PLUMED 2.1 and allows for a proper implementation of the DESTDIR feature required by unix distributions.</p>
<p>Using the standard behavior explained in the autoconf documentation, it is possible to change the paths for plumed install either during configure (with <code>--prefix</code>) or by setting <code>prefix</code> during <code>make install</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<table align="center" frame="void" width="98%" cellpadding="2%">
<tr><td align="left" valign="center"> 
Hosted by GitHub &nbsp;
<a href="http://github.com"><img src="octocat.png" width="88" height="66"  alt="GitHub Logo" /></a>
<!--Generated by  &#160; --> <a href="http://www.doxygen.org/index.html">
</td><td width=90% align="right">
<img class="footer" src="doxygen.png" alt="doxygen" align="right"/>
</a> 1.8.17
</td> </tr> 
</table>
</small></address>
</body>
</html>
