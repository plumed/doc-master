<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: PLMD::Plumed Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../user-doc/html/index.html"> <img src="developer-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p_l_m_d.html">PLMD</a></li><li class="navelem"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="class_p_l_m_d_1_1_plumed-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PLMD::Plumed Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ wrapper for <a class="el" href="structplumed.html">plumed</a>.  
 <a href="class_p_l_m_d_1_1_plumed.html#details">More...</a></p>

<p><code>#include &lt;Plumed.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1add__buffer__to.html">add_buffer_to</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_c_string.html">CString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class used to rethrow PLUMED exceptions.  <a href="class_p_l_m_d_1_1_plumed_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_exception_debug.html">ExceptionDebug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to rethrow a <a class="el" href="class_p_l_m_d_1_1_exception_debug.html" title="Class representing a debug error (can only be thrown when using debug options)">PLMD::ExceptionDebug</a>.  <a href="class_p_l_m_d_1_1_plumed_1_1_exception_debug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_exception_error.html">ExceptionError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to rethrow a <a class="el" href="class_p_l_m_d_1_1_exception_error.html" title="Class representing a generic error.">PLMD::ExceptionError</a>.  <a href="class_p_l_m_d_1_1_plumed_1_1_exception_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_exception_type_error.html">ExceptionTypeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a wrong pointer is passed to the PLUMED interface.  <a href="class_p_l_m_d_1_1_plumed_1_1_exception_type_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1finalize__plumed__error.html">finalize_plumed_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class to simplify <a class="el" href="structplumed__error.html" title="Small structure that is only defined locally to retrieve errors.">plumed_error</a> finalization.  <a href="class_p_l_m_d_1_1_plumed_1_1finalize__plumed__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_invalid.html">Invalid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when trying to access an invalid plumed object.  <a href="class_p_l_m_d_1_1_plumed_1_1_invalid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_lepton_exception.html">LeptonException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to rethrow Lepton exceptions.  <a href="class_p_l_m_d_1_1_plumed_1_1_lepton_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1rethrow__nested.html">rethrow_nested</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used by exception_dispatch.  <a href="class_p_l_m_d_1_1_plumed_1_1rethrow__nested.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1rethrow__not__nested.html">rethrow_not_nested</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used by exception_dispatch.  <a href="class_p_l_m_d_1_1_plumed_1_1rethrow__not__nested.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_safe_ptr.html">SafePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class that wraps <a class="el" href="structplumed__safeptr.html" title="Structure holding a typesafe pointer.">plumed_safeptr</a> in order to make its initialization easier.  <a href="class_p_l_m_d_1_1_plumed_1_1_safe_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small structure used to pass elements of a shape initializer_list.  <a href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16c8f99aaa9e6d86bf404120d6c9e3d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a16c8f99aaa9e6d86bf404120d6c9e3d9">Plumed</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a16c8f99aaa9e6d86bf404120d6c9e3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_p_l_m_d_1_1_plumed.html#a16c8f99aaa9e6d86bf404120d6c9e3d9">More...</a><br /></td></tr>
<tr class="separator:a16c8f99aaa9e6d86bf404120d6c9e3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c4a0223efb7dacfc8c52b0ea173f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a14c4a0223efb7dacfc8c52b0ea173f03">Plumed</a> (const char *c) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a14c4a0223efb7dacfc8c52b0ea173f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object from a FORTRAN char* handler.  <a href="class_p_l_m_d_1_1_plumed.html#a14c4a0223efb7dacfc8c52b0ea173f03">More...</a><br /></td></tr>
<tr class="separator:a14c4a0223efb7dacfc8c52b0ea173f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cbf39109e711f1edd840a597510583"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ad9cbf39109e711f1edd840a597510583">Plumed</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;p) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ad9cbf39109e711f1edd840a597510583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_p_l_m_d_1_1_plumed.html#ad9cbf39109e711f1edd840a597510583">More...</a><br /></td></tr>
<tr class="separator:ad9cbf39109e711f1edd840a597510583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ef9f849c146c0a26c9a325b101a9d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a95ef9f849c146c0a26c9a325b101a9d1">Plumed</a> (<a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&amp;p) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a95ef9f849c146c0a26c9a325b101a9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="class_p_l_m_d_1_1_plumed.html#a95ef9f849c146c0a26c9a325b101a9d1">More...</a><br /></td></tr>
<tr class="separator:a95ef9f849c146c0a26c9a325b101a9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548549156551adbac5e273bf15400e40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a548549156551adbac5e273bf15400e40">Plumed</a> (<a class="el" href="structplumed.html">plumed</a> p) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a548549156551adbac5e273bf15400e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object from a C plumed structure.  <a href="class_p_l_m_d_1_1_plumed.html#a548549156551adbac5e273bf15400e40">More...</a><br /></td></tr>
<tr class="separator:a548549156551adbac5e273bf15400e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea615c093a6f18a46878c7c4994b9be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a0ea615c093a6f18a46878c7c4994b9be">Plumed</a> (void *v) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a0ea615c093a6f18a46878c7c4994b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference from a void* pointer.  <a href="class_p_l_m_d_1_1_plumed.html#a0ea615c093a6f18a46878c7c4994b9be">More...</a><br /></td></tr>
<tr class="separator:a0ea615c093a6f18a46878c7c4994b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96546235f4f2b03eb0e4edd9ef99e44b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a96546235f4f2b03eb0e4edd9ef99e44b">~Plumed</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a96546235f4f2b03eb0e4edd9ef99e44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_p_l_m_d_1_1_plumed.html#a96546235f4f2b03eb0e4edd9ef99e44b">More...</a><br /></td></tr>
<tr class="separator:a96546235f4f2b03eb0e4edd9ef99e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafce5a0fd0962ac99de73f8d420c442"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:aeafce5a0fd0962ac99de73f8d420c442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442">cmd</a> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:aeafce5a0fd0962ac99de73f8d420c442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to this plumed object.  <a href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442">More...</a><br /></td></tr>
<tr class="separator:aeafce5a0fd0962ac99de73f8d420c442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b15c01254b39bc5dab7257086e58aa0"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a7b15c01254b39bc5dab7257086e58aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a7b15c01254b39bc5dab7257086e58aa0">cmd</a> (Key &amp;&amp;key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a7b15c01254b39bc5dab7257086e58aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to this plumed object.  <a href="class_p_l_m_d_1_1_plumed.html#a7b15c01254b39bc5dab7257086e58aa0">More...</a><br /></td></tr>
<tr class="separator:a7b15c01254b39bc5dab7257086e58aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f86d368056b66144eaeae9b3b49dc"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:aaf7f86d368056b66144eaeae9b3b49dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#aaf7f86d368056b66144eaeae9b3b49dc">cmd</a> (Key &amp;&amp;key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *shape)</td></tr>
<tr class="memdesc:aaf7f86d368056b66144eaeae9b3b49dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to this plumed object.  <a href="class_p_l_m_d_1_1_plumed.html#aaf7f86d368056b66144eaeae9b3b49dc">More...</a><br /></td></tr>
<tr class="separator:aaf7f86d368056b66144eaeae9b3b49dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d76d9408a34cf24db726577c08810"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename I , typename std::enable_if&lt; std::is_integral&lt; I &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0c2d76d9408a34cf24db726577c08810"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a0c2d76d9408a34cf24db726577c08810">cmd</a> (Key &amp;&amp;key, T *val, I nelem)</td></tr>
<tr class="memdesc:a0c2d76d9408a34cf24db726577c08810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to this plumed object.  <a href="class_p_l_m_d_1_1_plumed.html#a0c2d76d9408a34cf24db726577c08810">More...</a><br /></td></tr>
<tr class="separator:a0c2d76d9408a34cf24db726577c08810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a17010be867f35f0a919dc402223895"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a9a17010be867f35f0a919dc402223895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a9a17010be867f35f0a919dc402223895">cmd</a> (Key &amp;&amp;key, T *val, std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt; shape)</td></tr>
<tr class="memdesc:a9a17010be867f35f0a919dc402223895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to this plumed object.  <a href="class_p_l_m_d_1_1_plumed.html#a9a17010be867f35f0a919dc402223895">More...</a><br /></td></tr>
<tr class="separator:a9a17010be867f35f0a919dc402223895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e86d7dc773834ac81ce1d447193d08e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a6e86d7dc773834ac81ce1d447193d08e">decref</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a6e86d7dc773834ac81ce1d447193d08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease reference counter.  <a href="class_p_l_m_d_1_1_plumed.html#a6e86d7dc773834ac81ce1d447193d08e">More...</a><br /></td></tr>
<tr class="separator:a6e86d7dc773834ac81ce1d447193d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03be603fa1dd023719d578bd8ac173ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a03be603fa1dd023719d578bd8ac173ad">incref</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a03be603fa1dd023719d578bd8ac173ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference counter.  <a href="class_p_l_m_d_1_1_plumed.html#a03be603fa1dd023719d578bd8ac173ad">More...</a><br /></td></tr>
<tr class="separator:a03be603fa1dd023719d578bd8ac173ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10adb1b218dabada64b9333389fe36f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a10adb1b218dabada64b9333389fe36f8">operator bool</a> () const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a10adb1b218dabada64b9333389fe36f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">valid()</a>.  <a href="class_p_l_m_d_1_1_plumed.html#a10adb1b218dabada64b9333389fe36f8">More...</a><br /></td></tr>
<tr class="separator:a10adb1b218dabada64b9333389fe36f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2189502027361cf9b4ce8ac081a1aa97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a2189502027361cf9b4ce8ac081a1aa97">operator plumed</a> () const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a2189502027361cf9b4ce8ac081a1aa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the C plumed structure for this object.  <a href="class_p_l_m_d_1_1_plumed.html#a2189502027361cf9b4ce8ac081a1aa97">More...</a><br /></td></tr>
<tr class="separator:a2189502027361cf9b4ce8ac081a1aa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebfbc6a2f2a305e6d295880d5633bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#afebfbc6a2f2a305e6d295880d5633bdc">operator=</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;p) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:afebfbc6a2f2a305e6d295880d5633bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="class_p_l_m_d_1_1_plumed.html#afebfbc6a2f2a305e6d295880d5633bdc">More...</a><br /></td></tr>
<tr class="separator:afebfbc6a2f2a305e6d295880d5633bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441119fdb7a182ab645b6fc735caa9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a441119fdb7a182ab645b6fc735caa9d3">operator=</a> (<a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&amp;p) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a441119fdb7a182ab645b6fc735caa9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="class_p_l_m_d_1_1_plumed.html#a441119fdb7a182ab645b6fc735caa9d3">More...</a><br /></td></tr>
<tr class="separator:a441119fdb7a182ab645b6fc735caa9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a1ac84f231646f09c1fe759b9a1370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#af4a1ac84f231646f09c1fe759b9a1370">toFortran</a> (char *c) const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:af4a1ac84f231646f09c1fe759b9a1370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a FORTRAN handler for this object.  <a href="class_p_l_m_d_1_1_plumed.html#af4a1ac84f231646f09c1fe759b9a1370">More...</a><br /></td></tr>
<tr class="separator:af4a1ac84f231646f09c1fe759b9a1370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469d7c35834d0749383986d278958edb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a469d7c35834d0749383986d278958edb">toVoid</a> () const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a469d7c35834d0749383986d278958edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a void* handler for this object.  <a href="class_p_l_m_d_1_1_plumed.html#a469d7c35834d0749383986d278958edb">More...</a><br /></td></tr>
<tr class="separator:a469d7c35834d0749383986d278958edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571fb5e7faacfd5033ff58ab8bf61a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a9571fb5e7faacfd5033ff58ab8bf61a1">useCount</a> () const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a9571fb5e7faacfd5033ff58ab8bf61a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of references to this object.  <a href="class_p_l_m_d_1_1_plumed.html#a9571fb5e7faacfd5033ff58ab8bf61a1">More...</a><br /></td></tr>
<tr class="separator:a9571fb5e7faacfd5033ff58ab8bf61a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c27732166898a8d219eaba6d399492b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">valid</a> () const <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a1c27732166898a8d219eaba6d399492b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object is valid.  <a href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">More...</a><br /></td></tr>
<tr class="separator:a1c27732166898a8d219eaba6d399492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac1fa52234845e6aa67e50211f96e6dee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1fa52234845e6aa67e50211f96e6dee">dlopen</a> (const char *<a class="el" href="_benchmark_8cpp.html#a4d455efceee21e97d8e21ee40e9b4a20">path</a>) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ac1fa52234845e6aa67e50211f96e6dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PLUMED object loading a specific kernel.  <a href="class_p_l_m_d_1_1_plumed.html#ac1fa52234845e6aa67e50211f96e6dee">More...</a><br /></td></tr>
<tr class="separator:ac1fa52234845e6aa67e50211f96e6dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597d9cce3ed208bf8ccd937d99d2e8ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a597d9cce3ed208bf8ccd937d99d2e8ef">dlopen</a> (const char *<a class="el" href="_benchmark_8cpp.html#a4d455efceee21e97d8e21ee40e9b4a20">path</a>, int mode) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a597d9cce3ed208bf8ccd937d99d2e8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PLUMED object loading a specific kernel.  <a href="class_p_l_m_d_1_1_plumed.html#a597d9cce3ed208bf8ccd937d99d2e8ef">More...</a><br /></td></tr>
<tr class="separator:a597d9cce3ed208bf8ccd937d99d2e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f71ff0757dcd14d2bd3d1bdbe1675"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ad18f71ff0757dcd14d2bd3d1bdbe1675">dlsym</a> (void *dlhandle) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ad18f71ff0757dcd14d2bd3d1bdbe1675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PLUMED object loading from an already opened shared library.  <a href="class_p_l_m_d_1_1_plumed.html#ad18f71ff0757dcd14d2bd3d1bdbe1675">More...</a><br /></td></tr>
<tr class="separator:ad18f71ff0757dcd14d2bd3d1bdbe1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8745ebf5541c28cb326514009f619a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac8745ebf5541c28cb326514009f619a8">gcmd</a> (const char *key)</td></tr>
<tr class="memdesc:ac8745ebf5541c28cb326514009f619a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#ac8745ebf5541c28cb326514009f619a8">More...</a><br /></td></tr>
<tr class="separator:ac8745ebf5541c28cb326514009f619a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfdf00e276d2539d0f3af604526742e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bfdf00e276d2539d0f3af604526742e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4bfdf00e276d2539d0f3af604526742e">gcmd</a> (const char *key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a4bfdf00e276d2539d0f3af604526742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#a4bfdf00e276d2539d0f3af604526742e">More...</a><br /></td></tr>
<tr class="separator:a4bfdf00e276d2539d0f3af604526742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a46e9d42be27cc1141efd877620fac9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M &gt; </td></tr>
<tr class="memitem:a4a46e9d42be27cc1141efd877620fac9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4a46e9d42be27cc1141efd877620fac9">gcmd</a> (const char *key, T *val, M &amp;&amp;more)</td></tr>
<tr class="memdesc:a4a46e9d42be27cc1141efd877620fac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#a4a46e9d42be27cc1141efd877620fac9">More...</a><br /></td></tr>
<tr class="separator:a4a46e9d42be27cc1141efd877620fac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e490e15e6cfc05badb02d528a5b4e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2e490e15e6cfc05badb02d528a5b4e5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#aa2e490e15e6cfc05badb02d528a5b4e5">gcmd</a> (const char *key, T *val, std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt; shape)</td></tr>
<tr class="memdesc:aa2e490e15e6cfc05badb02d528a5b4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#aa2e490e15e6cfc05badb02d528a5b4e5">More...</a><br /></td></tr>
<tr class="separator:aa2e490e15e6cfc05badb02d528a5b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c0209ed84c21f4c9dba250e0e4163e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a79c0209ed84c21f4c9dba250e0e4163e">gcreate</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a79c0209ed84c21f4c9dba250e0e4163e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#a79c0209ed84c21f4c9dba250e0e4163e">More...</a><br /></td></tr>
<tr class="separator:a79c0209ed84c21f4c9dba250e0e4163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f55a75e3232bad8b71b341f34a87c11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a2f55a75e3232bad8b71b341f34a87c11">gfinalize</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a2f55a75e3232bad8b71b341f34a87c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize global-plumed.  <a href="class_p_l_m_d_1_1_plumed.html#a2f55a75e3232bad8b71b341f34a87c11">More...</a><br /></td></tr>
<tr class="separator:a2f55a75e3232bad8b71b341f34a87c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96d43048d89121d89c31195ade11fb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a9a96d43048d89121d89c31195ade11fb">ginitialized</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a9a96d43048d89121d89c31195ade11fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if global-plumed has been initialized.  <a href="class_p_l_m_d_1_1_plumed.html#a9a96d43048d89121d89c31195ade11fb">More...</a><br /></td></tr>
<tr class="separator:a9a96d43048d89121d89c31195ade11fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04f0f7da7efb081b2b2bb66e0ba58da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ae04f0f7da7efb081b2b2bb66e0ba58da">global</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ae04f0f7da7efb081b2b2bb66e0ba58da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> global object.  <a href="class_p_l_m_d_1_1_plumed.html#ae04f0f7da7efb081b2b2bb66e0ba58da">More...</a><br /></td></tr>
<tr class="separator:ae04f0f7da7efb081b2b2bb66e0ba58da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab914eefe610aed5b41db61848f3191db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ab914eefe610aed5b41db61848f3191db">gvalid</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ab914eefe610aed5b41db61848f3191db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if global-plumed is valid.  <a href="class_p_l_m_d_1_1_plumed.html#ab914eefe610aed5b41db61848f3191db">More...</a><br /></td></tr>
<tr class="separator:ab914eefe610aed5b41db61848f3191db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb66f1ea949d626985b1e6ecfad1e9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a1bcb66f1ea949d626985b1e6ecfad1e9">installed</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:a1bcb66f1ea949d626985b1e6ecfad1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if plumed is installed (for runtime binding)  <a href="class_p_l_m_d_1_1_plumed.html#a1bcb66f1ea949d626985b1e6ecfad1e9">More...</a><br /></td></tr>
<tr class="separator:a1bcb66f1ea949d626985b1e6ecfad1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7939f1aad665d54ea7bc1443edb59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#af6d7939f1aad665d54ea7bc1443edb59">makeInvalid</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:af6d7939f1aad665d54ea7bc1443edb59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_invalid.html" title="Thrown when trying to access an invalid plumed object.">Invalid</a> constructor.  <a href="class_p_l_m_d_1_1_plumed.html#af6d7939f1aad665d54ea7bc1443edb59">More...</a><br /></td></tr>
<tr class="separator:af6d7939f1aad665d54ea7bc1443edb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f46aeedbd60c25c65d1124da92f5db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ad7f46aeedbd60c25c65d1124da92f5db">makeValid</a> () <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="memdesc:ad7f46aeedbd60c25c65d1124da92f5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a valid <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">PLMD::Plumed</a> object.  <a href="class_p_l_m_d_1_1_plumed.html#ad7f46aeedbd60c25c65d1124da92f5db">More...</a><br /></td></tr>
<tr class="separator:ad7f46aeedbd60c25c65d1124da92f5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c623a9e6268c397e160cdefd7d88b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a96c623a9e6268c397e160cdefd7d88b8">plumed_cmd_cxx</a> (<a class="el" href="structplumed.html">plumed</a> p, const char *key, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:a96c623a9e6268c397e160cdefd7d88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#a96c623a9e6268c397e160cdefd7d88b8">More...</a><br /></td></tr>
<tr class="separator:a96c623a9e6268c397e160cdefd7d88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2682bf30786af79e28e8fc41367dc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf2682bf30786af79e28e8fc41367dc7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#acf2682bf30786af79e28e8fc41367dc7">plumed_cmd_cxx</a> (<a class="el" href="structplumed.html">plumed</a> p, const char *key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t nelem, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:acf2682bf30786af79e28e8fc41367dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#acf2682bf30786af79e28e8fc41367dc7">More...</a><br /></td></tr>
<tr class="separator:acf2682bf30786af79e28e8fc41367dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3ce28b9f025bd156ea7efac7800c1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade3ce28b9f025bd156ea7efac7800c1f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ade3ce28b9f025bd156ea7efac7800c1f">plumed_cmd_cxx</a> (<a class="el" href="structplumed.html">plumed</a> p, const char *key, T *val, const <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *shape, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:ade3ce28b9f025bd156ea7efac7800c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#ade3ce28b9f025bd156ea7efac7800c1f">More...</a><br /></td></tr>
<tr class="separator:ade3ce28b9f025bd156ea7efac7800c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa61099a7d884d3b043c6dcfd66b650"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfa61099a7d884d3b043c6dcfd66b650"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#acfa61099a7d884d3b043c6dcfd66b650">plumed_cmd_cxx</a> (<a class="el" href="structplumed.html">plumed</a> p, const char *key, T *val, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:acfa61099a7d884d3b043c6dcfd66b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#acfa61099a7d884d3b043c6dcfd66b650">More...</a><br /></td></tr>
<tr class="separator:acfa61099a7d884d3b043c6dcfd66b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3e29d320cd1e01f643e6f64335562f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d3e29d320cd1e01f643e6f64335562f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a2d3e29d320cd1e01f643e6f64335562f">plumed_cmd_cxx</a> (<a class="el" href="structplumed.html">plumed</a> p, const char *key, T val, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:a2d3e29d320cd1e01f643e6f64335562f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#a2d3e29d320cd1e01f643e6f64335562f">More...</a><br /></td></tr>
<tr class="separator:a2d3e29d320cd1e01f643e6f64335562f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828abbd8f2b963dec35e8f81ff532114"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a828abbd8f2b963dec35e8f81ff532114">plumed_error_rethrow_cxx</a> (<a class="el" href="structplumed__error.html">plumed_error</a> h)</td></tr>
<tr class="separator:a828abbd8f2b963dec35e8f81ff532114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab885bf74a9d51adf6f3c3af599bb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73ab885bf74a9d51adf6f3c3af599bb7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a73ab885bf74a9d51adf6f3c3af599bb7">plumed_gcmd_cxx</a> (const char *key, T val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t nelem, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:a73ab885bf74a9d51adf6f3c3af599bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#a73ab885bf74a9d51adf6f3c3af599bb7">More...</a><br /></td></tr>
<tr class="separator:a73ab885bf74a9d51adf6f3c3af599bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83375c8a94f5cd795b93e188a9c105eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83375c8a94f5cd795b93e188a9c105eb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a83375c8a94f5cd795b93e188a9c105eb">plumed_gcmd_cxx</a> (const char *key, T val, const <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *shape, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:a83375c8a94f5cd795b93e188a9c105eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#a83375c8a94f5cd795b93e188a9c105eb">More...</a><br /></td></tr>
<tr class="separator:a83375c8a94f5cd795b93e188a9c105eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c1c8b83f9eaaf9121a077b9cfc313e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4c1c8b83f9eaaf9121a077b9cfc313e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#af4c1c8b83f9eaaf9121a077b9cfc313e">plumed_gcmd_cxx</a> (const char *key, T val, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:af4c1c8b83f9eaaf9121a077b9cfc313e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#af4c1c8b83f9eaaf9121a077b9cfc313e">More...</a><br /></td></tr>
<tr class="separator:af4c1c8b83f9eaaf9121a077b9cfc313e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abf305d8d8ee15aaf6972d556c68e8be1"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::size_t, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#abf305d8d8ee15aaf6972d556c68e8be1">append_size</a> (std::size_t *shape, std::size_t newindex)</td></tr>
<tr class="memdesc:abf305d8d8ee15aaf6972d556c68e8be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal utility to append a shape.  <a href="class_p_l_m_d_1_1_plumed.html#abf305d8d8ee15aaf6972d556c68e8be1">More...</a><br /></td></tr>
<tr class="separator:abf305d8d8ee15aaf6972d556c68e8be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">cmd_helper</a> (Key &amp;&amp;key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a4b46a6679c2fc99eab66714b064c6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for interpreting commands.  <a href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">More...</a><br /></td></tr>
<tr class="separator:a4b46a6679c2fc99eab66714b064c6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;wrapper::has_size_and_data&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">cmd_helper</a> (Key &amp;&amp;key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a4b46a6679c2fc99eab66714b064c6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper with size/data val (typically, std::vector, std::string, small_vector, etc) temporaries are detected and the information is propragated  <a href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">More...</a><br /></td></tr>
<tr class="separator:a4b46a6679c2fc99eab66714b064c6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;!wrapper::has_size_and_data&lt; T &gt;::value &amp;&amp;std::is_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">cmd_helper</a> (Key &amp;&amp;key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a4b46a6679c2fc99eab66714b064c6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper with raw pointer val temporaries are not detected.  <a href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">More...</a><br /></td></tr>
<tr class="separator:a4b46a6679c2fc99eab66714b064c6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;!wrapper::has_size_and_data&lt; T &gt;::value &amp;&amp;!std::is_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a4b46a6679c2fc99eab66714b064c6319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">cmd_helper</a> (Key &amp;&amp;key, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a4b46a6679c2fc99eab66714b064c6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper in remaining cases, that is when val is passed by value temporaries are not detected.  <a href="class_p_l_m_d_1_1_plumed.html#a4b46a6679c2fc99eab66714b064c6319">More...</a><br /></td></tr>
<tr class="separator:a4b46a6679c2fc99eab66714b064c6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a7c299a300129cd43b4f8e0abe21a42f8">cmd_helper_with_shape</a> (Key &amp;&amp;key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *shape, bool nocopy=false)</td></tr>
<tr class="memdesc:a7c299a300129cd43b4f8e0abe21a42f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper_with_shape with custom array val (includes std::array and C arrays) nocopy information is propagated  <a href="class_p_l_m_d_1_1_plumed.html#a7c299a300129cd43b4f8e0abe21a42f8">More...</a><br /></td></tr>
<tr class="separator:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a7c299a300129cd43b4f8e0abe21a42f8">cmd_helper_with_shape</a> (Key &amp;&amp;key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *shape, bool nocopy=false)</td></tr>
<tr class="memdesc:a7c299a300129cd43b4f8e0abe21a42f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper_with_shape with pointer to simple type val.  <a href="class_p_l_m_d_1_1_plumed.html#a7c299a300129cd43b4f8e0abe21a42f8">More...</a><br /></td></tr>
<tr class="separator:a7c299a300129cd43b4f8e0abe21a42f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1e8ce78df5db69a2d601a745c734ccb">cmd_with_nelem</a> (Key &amp;&amp;key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t nelem)</td></tr>
<tr class="memdesc:ac1e8ce78df5db69a2d601a745c734ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper_with_nelem with custom array val (includes std::array) this helper is only used for backward compatibility, so it does not need to take into account the copyability of the pointer  <a href="class_p_l_m_d_1_1_plumed.html#ac1e8ce78df5db69a2d601a745c734ccb">More...</a><br /></td></tr>
<tr class="separator:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1e8ce78df5db69a2d601a745c734ccb">cmd_with_nelem</a> (Key &amp;&amp;key, T *val, <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t nelem)</td></tr>
<tr class="memdesc:ac1e8ce78df5db69a2d601a745c734ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_helper_with_nelem with pointer to simple type val.  <a href="class_p_l_m_d_1_1_plumed.html#ac1e8ce78df5db69a2d601a745c734ccb">More...</a><br /></td></tr>
<tr class="separator:ac1e8ce78df5db69a2d601a745c734ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b13f07c98ea729f77cd8efcb385a877"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::size_t, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a1b13f07c98ea729f77cd8efcb385a877">make_shape</a> (std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt; shape)</td></tr>
<tr class="memdesc:a1b13f07c98ea729f77cd8efcb385a877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal tool to convert initializer_list to shape This is just taking an initializer list and making a std::array.  <a href="class_p_l_m_d_1_1_plumed.html#a1b13f07c98ea729f77cd8efcb385a877">More...</a><br /></td></tr>
<tr class="separator:a1b13f07c98ea729f77cd8efcb385a877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a321d908969eac8eb57b158d03be5c33b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a321d908969eac8eb57b158d03be5c33b">cmd_priv</a> (<a class="el" href="structplumed.html">plumed</a> <a class="el" href="class_p_l_m_d_1_1_plumed.html#a33431ebf1fb7f4047b8045193b84497e">main</a>, const char *key, <a class="el" href="class_p_l_m_d_1_1_plumed_1_1_safe_ptr.html">SafePtr</a> &amp;safe, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:a321d908969eac8eb57b158d03be5c33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private version of cmd.  <a href="class_p_l_m_d_1_1_plumed.html#a321d908969eac8eb57b158d03be5c33b">More...</a><br /></td></tr>
<tr class="separator:a321d908969eac8eb57b158d03be5c33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c685631bd88026ccaadf2885c24586"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a57c685631bd88026ccaadf2885c24586"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a57c685631bd88026ccaadf2885c24586">exception_dispatch</a> (<a class="el" href="structplumed__error.html">plumed_error</a> &amp;h, F f)</td></tr>
<tr class="memdesc:a57c685631bd88026ccaadf2885c24586"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal utility to dispatch exceptions based on the <a class="el" href="structplumed__error.html" title="Small structure that is only defined locally to retrieve errors.">plumed_error</a> object.  <a href="class_p_l_m_d_1_1_plumed.html#a57c685631bd88026ccaadf2885c24586">More...</a><br /></td></tr>
<tr class="separator:a57c685631bd88026ccaadf2885c24586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f9e23b802d413176d349df9dc07678"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#aa2f9e23b802d413176d349df9dc07678">rethrow</a> ()</td></tr>
<tr class="memdesc:aa2f9e23b802d413176d349df9dc07678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rethrow the current exception.  <a href="class_p_l_m_d_1_1_plumed.html#aa2f9e23b802d413176d349df9dc07678">More...</a><br /></td></tr>
<tr class="separator:aa2f9e23b802d413176d349df9dc07678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67390b60953c14548b5b66d14810a92a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a67390b60953c14548b5b66d14810a92a">rethrow</a> (<a class="el" href="structplumed__error.html">plumed_error</a> &amp;h)</td></tr>
<tr class="memdesc:a67390b60953c14548b5b66d14810a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function that rethrows an exception with all the nested ones.  <a href="class_p_l_m_d_1_1_plumed.html#a67390b60953c14548b5b66d14810a92a">More...</a><br /></td></tr>
<tr class="separator:a67390b60953c14548b5b66d14810a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a33431ebf1fb7f4047b8045193b84497e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplumed.html">plumed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a33431ebf1fb7f4047b8045193b84497e">main</a></td></tr>
<tr class="memdesc:a33431ebf1fb7f4047b8045193b84497e"><td class="mdescLeft">&#160;</td><td class="mdescRight">C structure.  <a href="class_p_l_m_d_1_1_plumed.html#a33431ebf1fb7f4047b8045193b84497e">More...</a><br /></td></tr>
<tr class="separator:a33431ebf1fb7f4047b8045193b84497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ace5f566cbb7d9ca8ecc2f62684342185"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ace5f566cbb7d9ca8ecc2f62684342185">operator!=</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:ace5f566cbb7d9ca8ecc2f62684342185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba27683c67b1a8278680b1abf9a917"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a5dba27683c67b1a8278680b1abf9a917">operator&lt;</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:a5dba27683c67b1a8278680b1abf9a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a45d4e5589b27b4faa44768234689e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a9a45d4e5589b27b4faa44768234689e5">operator&lt;=</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:a9a45d4e5589b27b4faa44768234689e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae3c192ace0d92665acc0c38769e3f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#a8ae3c192ace0d92665acc0c38769e3f1">operator==</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:a8ae3c192ace0d92665acc0c38769e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6df092956c1574f0d61beb93d04ec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#afb6df092956c1574f0d61beb93d04ec8">operator&gt;</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:afb6df092956c1574f0d61beb93d04ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73314e2956142f1ee76228527683293"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac73314e2956142f1ee76228527683293">operator&gt;=</a> (const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;a, const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;b) <a class="el" href="asmjit_2asmjit__apibegin_8h.html#a189faadd7f99f6c354db09acbb2aafcd">noexcept</a></td></tr>
<tr class="separator:ac73314e2956142f1ee76228527683293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa53b07c23b79bbeb581f77866a5f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1fa53b07c23b79bbeb581f77866a5f9">plumed_gcmd_cxx</a> (const char *key, <a class="el" href="structplumed__error.html">plumed_error</a> *error=<a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a>)</td></tr>
<tr class="memdesc:ac1fa53b07c23b79bbeb581f77866a5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception.  <a href="class_p_l_m_d_1_1_plumed.html#ac1fa53b07c23b79bbeb581f77866a5f9">More...</a><br /></td></tr>
<tr class="separator:ac1fa53b07c23b79bbeb581f77866a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ wrapper for <a class="el" href="structplumed.html">plumed</a>. </p>
<p>This class provides a C++ interface to PLUMED. It only containts a <a class="el" href="structplumed.html">plumed</a> object, but wraps it with a number of useful methods. All methods are inlined so as to avoid the compilation of an extra c++ file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a16c8f99aaa9e6d86bf404120d6c9e3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c8f99aaa9e6d86bf404120d6c9e3d9">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Notice that when using runtime binding the constructed object might be invalid. One might check it using the <a class="el" href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">valid()</a> method.</p>
<dl class="section note"><dt>Note</dt><dd>Performs the same task a <a class="el" href="structplumed.html#ad2c7269d82d4bfecb0118375ecd12177" title="Constructor.">plumed_create()</a> </dd></dl>

</div>
</div>
<a id="a14c4a0223efb7dacfc8c52b0ea173f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c4a0223efb7dacfc8c52b0ea173f03">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object from a FORTRAN char* handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The FORTRAN handler (a char[32]).</td></tr>
  </table>
  </dd>
</dl>
<p>The reference counter for the corresponding object will be increased to make sure that the object will be available after plumed_f_finalize is called if the created object is still in scope. </p>

</div>
</div>
<a id="a0ea615c093a6f18a46878c7c4994b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea615c093a6f18a46878c7c4994b9be">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a reference from a void* pointer. </p>
<p>Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="a548549156551adbac5e273bf15400e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548549156551adbac5e273bf15400e40">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object from a C plumed structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The C plumed structure.</td></tr>
  </table>
  </dd>
</dl>
<p>The reference counter for the corresponding object will be increased to make sure that the object will be available after plumed_finalize is called if the created object is still in scope. </p>

</div>
</div>
<a id="ad9cbf39109e711f1edd840a597510583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cbf39109e711f1edd840a597510583">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Takes a reference, incrementing the reference counter of the corresponding object. </p>

</div>
</div>
<a id="a95ef9f849c146c0a26c9a325b101a9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ef9f849c146c0a26c9a325b101a9d1">&#9670;&nbsp;</a></span>Plumed() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::Plumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Available as of PLUMED 2.5. Only if move semantics is enabled. </p>

</div>
</div>
<a id="a96546235f4f2b03eb0e4edd9ef99e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96546235f4f2b03eb0e4edd9ef99e44b">&#9670;&nbsp;</a></span>~Plumed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PLMD::Plumed::~Plumed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>It calls plumed_finalize(). Notice that this is done also if the constructor failed (that is, if it returned an invalid object). This allows declaring <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> objects also if PLUMED is actually not available, provided one does not use the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442">cmd</a> method.</p>
<p>Destructor is virtual so as to allow correct inheritance from <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf305d8d8ee15aaf6972d556c68e8be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf305d8d8ee15aaf6972d556c68e8be1">&#9670;&nbsp;</a></span>append_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::size_t,5&gt; PLMD::Plumed::append_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>newindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal utility to append a shape. </p>
<p>Create a new shape where newindex has been appended to the last non zero element. </p>

</div>
</div>
<a id="aeafce5a0fd0962ac99de73f8d420c442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafce5a0fd0962ac99de73f8d420c442">&#9670;&nbsp;</a></span>cmd() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to this plumed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Similar to plumed_cmd(). It actually called plumed_cmd_nothrow() and rethrow any exception raised within PLUMED. </dd></dl>

</div>
</div>
<a id="a7b15c01254b39bc5dab7257086e58aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b15c01254b39bc5dab7257086e58aa0">&#9670;&nbsp;</a></span>cmd() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to this plumed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
    <tr><td class="paramname">val</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf7f86d368056b66144eaeae9b3b49dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7f86d368056b66144eaeae9b3b49dc">&#9670;&nbsp;</a></span>cmd() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to this plumed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
    <tr><td class="paramname">val</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload accepts a pointer and corresponding shape information. Shape is passed a size_t pointer, but the overload accepting an initializer_list has a more friendly syntax. </dd></dl>

</div>
</div>
<a id="a0c2d76d9408a34cf24db726577c08810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d76d9408a34cf24db726577c08810">&#9670;&nbsp;</a></span>cmd() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename I , typename std::enable_if&lt; std::is_integral&lt; I &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>nelem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to this plumed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
    <tr><td class="paramname">val</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload accepts a pointer and corresponding size information. It's usage is discouraged: the overload accepting shape information should be preferred. </dd></dl>

</div>
</div>
<a id="a9a17010be867f35f0a919dc402223895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a17010be867f35f0a919dc402223895">&#9670;&nbsp;</a></span>cmd() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to this plumed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
    <tr><td class="paramname">val</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload accepts a pointer and corresponding shape information. Shape is passed a size_t pointer, but the overload accepting an initializer_list has a more friendly syntax. </dd></dl>

</div>
</div>
<a id="a4b46a6679c2fc99eab66714b064c6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46a6679c2fc99eab66714b064c6319">&#9670;&nbsp;</a></span>cmd_helper() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for interpreting commands. </p>
<p><b>They are all internals</b>. cmd_helper is called when we have no shape information associated. cmd_helper_with_shape is called when we have shape information associated. cmd_helper_with_nelem is called when we have size information associated. The nocopy bool tells us if this pointer is pointing to a temporary variable, it is propagated by the cmd_helper_with_shape version It makes sure PLUMED will not keep a copy. The variants below change for the type of the val argument There is a chain of SFINAE conditions. This would be better implement with if constexpr, but we avoid doing so to keep this compatible with C++11. cmd_helper with custom array val (includes std::array) temporaries are detected and the information is propragated </p>

</div>
</div>
<a id="a4b46a6679c2fc99eab66714b064c6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46a6679c2fc99eab66714b064c6319">&#9670;&nbsp;</a></span>cmd_helper() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;wrapper::has_size_and_data&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper with size/data val (typically, std::vector, std::string, small_vector, etc) temporaries are detected and the information is propragated </p>

</div>
</div>
<a id="a4b46a6679c2fc99eab66714b064c6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46a6679c2fc99eab66714b064c6319">&#9670;&nbsp;</a></span>cmd_helper() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;!wrapper::has_size_and_data&lt; T &gt;::value &amp;&amp;std::is_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper with raw pointer val temporaries are not detected. </p>
<p>We can indeed save the pointer, even if it's a temporary as it is in the case cmd("a",&amp;a) here we use std::remove_reference to detect properly pointers to arrays </p>

</div>
</div>
<a id="a4b46a6679c2fc99eab66714b064c6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46a6679c2fc99eab66714b064c6319">&#9670;&nbsp;</a></span>cmd_helper() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;!wrapper::has_size_and_data&lt; T &gt;::value &amp;&amp;!std::is_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper in remaining cases, that is when val is passed by value temporaries are not detected. </p>
<p>However, the argument is passed by value and its address is not copyable anyway </p>

</div>
</div>
<a id="a7c299a300129cd43b4f8e0abe21a42f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c299a300129cd43b4f8e0abe21a42f8">&#9670;&nbsp;</a></span>cmd_helper_with_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper_with_shape </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nocopy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper_with_shape with custom array val (includes std::array and C arrays) nocopy information is propagated </p>

</div>
</div>
<a id="a7c299a300129cd43b4f8e0abe21a42f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c299a300129cd43b4f8e0abe21a42f8">&#9670;&nbsp;</a></span>cmd_helper_with_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_helper_with_shape </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nocopy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper_with_shape with pointer to simple type val. </p>
<p>nocopy information is used to pass the proper flags to plumed </p>

</div>
</div>
<a id="a321d908969eac8eb57b158d03be5c33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321d908969eac8eb57b158d03be5c33b">&#9670;&nbsp;</a></span>cmd_priv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::cmd_priv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>main</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_safe_ptr.html">SafePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private version of cmd. </p>
<p>It is used here to avoid duplication of code between typesafe and not-typesafe versions </p>

</div>
</div>
<a id="ac1e8ce78df5db69a2d601a745c734ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e8ce78df5db69a2d601a745c734ccb">&#9670;&nbsp;</a></span>cmd_with_nelem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt; wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_with_nelem </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t&#160;</td>
          <td class="paramname"><em>nelem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper_with_nelem with custom array val (includes std::array) this helper is only used for backward compatibility, so it does not need to take into account the copyability of the pointer </p>

</div>
</div>
<a id="ac1e8ce78df5db69a2d601a745c734ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e8ce78df5db69a2d601a745c734ccb">&#9670;&nbsp;</a></span>cmd_with_nelem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename std::enable_if&lt;!wrapper::is_custom_array&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::cmd_with_nelem </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t&#160;</td>
          <td class="paramname"><em>nelem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cmd_helper_with_nelem with pointer to simple type val. </p>
<p>this helper is only used for backward compatibility, so it does not need to take into account the copyability of the pointer </p>

</div>
</div>
<a id="a6e86d7dc773834ac81ce1d447193d08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e86d7dc773834ac81ce1d447193d08e">&#9670;&nbsp;</a></span>decref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&amp; PLMD::Plumed::decref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease reference counter. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Using this method improperly might interfere with correct object construction and destruction. If you want to play with this, also try to compile using <code>-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1</code> and see what happens. </p>

</div>
</div>
<a id="ac1fa52234845e6aa67e50211f96e6dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fa52234845e6aa67e50211f96e6dee">&#9670;&nbsp;</a></span>dlopen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::dlopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a PLUMED object loading a specific kernel. </p>
<p>Available as of PLUMED 2.5.</p>
<p>It returns an object created with plumed_create_dlopen. The object is owned and is then finalized in the destructor. It can be used as follows: </p><pre class="fragment">  PLMD::Plumed p = PLMD::Plumed::dlopen("/path/to/libplumedKernel.so");
// or, equivalenty:
//    PLMD::Plumed p(PLMD::Plumed::dlopen("/path/to/libplumedKernel.so"));
  p.cmd("init");
</pre><p> or, equivalently, as </p><pre class="fragment">  auto p = PLMD::Plumed::dlopen("/path/to/libplumedKernel.so");
  p.cmd("init");
</pre> 
</div>
</div>
<a id="a597d9cce3ed208bf8ccd937d99d2e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597d9cce3ed208bf8ccd937d99d2e8ef">&#9670;&nbsp;</a></span>dlopen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::dlopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a PLUMED object loading a specific kernel. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Same as <a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1fa52234845e6aa67e50211f96e6dee">dlopen(const char* path)</a>, but allows a dlopen mode to be chosen explicitly. </p>

</div>
</div>
<a id="ad18f71ff0757dcd14d2bd3d1bdbe1675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18f71ff0757dcd14d2bd3d1bdbe1675">&#9670;&nbsp;</a></span>dlsym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::dlsym </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dlhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a PLUMED object loading from an already opened shared library. </p>
<p>Available as of PLUMED 2.8.</p>
<p>Same as <a class="el" href="class_p_l_m_d_1_1_plumed.html#ac1fa52234845e6aa67e50211f96e6dee">dlopen(const char* path)</a>, but searches functions in an already loaded library. See <a class="el" href="wrapper_2_plumed_8h.html#a43b54f45fa39f9d0e6a85c24c3306d17">plumed_create_dlsym</a>. </p>

</div>
</div>
<a id="a57c685631bd88026ccaadf2885c24586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c685631bd88026ccaadf2885c24586">&#9670;&nbsp;</a></span>exception_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void PLMD::Plumed::exception_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an internal utility to dispatch exceptions based on the <a class="el" href="structplumed__error.html" title="Small structure that is only defined locally to retrieve errors.">plumed_error</a> object. </p>
<p>It takes information about the exception to be thrown by the passed h object and use it to call function <a class="el" href="namespace_p_l_m_d_1_1lapack.html#ac69ef64c536ae618b85c6be71f8dfa1a">f()</a> on the resulting exception. Notice that:</p><ul>
<li>this function does not consider if the error is nested.</li>
<li>f should be a callable object, so that it can store information</li>
<li>f operator() should be a template function so as to act based on the type of its argument</li>
</ul>
<p>New exceptions added here should be kept in sync with <a class="el" href="_plumed_main_initializer_8cpp.html">core/PlumedMainInitializer.cpp</a></p>
<p>Notice that this function also finalizes in place <a class="el" href="structplumed__error.html" title="Small structure that is only defined locally to retrieve errors.">plumed_error</a> h, so as to avoid memory leaks. </p>

</div>
</div>
<a id="ac8745ebf5541c28cb326514009f619a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8745ebf5541c28cb326514009f619a8">&#9670;&nbsp;</a></span>gcmd() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gcmd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to global-plumed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the command to be executed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#a588aeb3774528a04419b210127559033" title="Tells to the global interface to execute a command.">plumed_gcmd()</a> </dd></dl>

</div>
</div>
<a id="a4bfdf00e276d2539d0f3af604526742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfdf00e276d2539d0f3af604526742e">&#9670;&nbsp;</a></span>gcmd() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gcmd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to global-plumed. </p>

</div>
</div>
<a id="a4a46e9d42be27cc1141efd877620fac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a46e9d42be27cc1141efd877620fac9">&#9670;&nbsp;</a></span>gcmd() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gcmd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>more</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to global-plumed. </p>
<p>This version detects passing size or shape as a pointer. </p>

</div>
</div>
<a id="aa2e490e15e6cfc05badb02d528a5b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e490e15e6cfc05badb02d528a5b4e5">&#9670;&nbsp;</a></span>gcmd() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gcmd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a command to global-plumed. </p>
<p>This version detects passing shape as an initializer_list. </p>

</div>
</div>
<a id="a79c0209ed84c21f4c9dba250e0e4163e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c0209ed84c21f4c9dba250e0e4163e">&#9670;&nbsp;</a></span>gcreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gcreate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize global-plumed. </p>
<dl class="section warning"><dt>Warning</dt><dd>Using the global objects in C++ is not recommended since they are difficult to use in an exception safe manner. In particular, one should explicitly catch exceptions to properly call <a class="el" href="class_p_l_m_d_1_1_plumed.html#a2f55a75e3232bad8b71b341f34a87c11" title="Finalize global-plumed.">gfinalize()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#a283adc98cf3ab483037ebdeaff8b83d2" title="Constructor for the global interface.">plumed_gcreate()</a> </dd></dl>

</div>
</div>
<a id="a2f55a75e3232bad8b71b341f34a87c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f55a75e3232bad8b71b341f34a87c11">&#9670;&nbsp;</a></span>gfinalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::gfinalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize global-plumed. </p>

</div>
</div>
<a id="a9a96d43048d89121d89c31195ade11fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a96d43048d89121d89c31195ade11fb">&#9670;&nbsp;</a></span>ginitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PLMD::Plumed::ginitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if global-plumed has been initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>true if global plumed object (see <a class="el" href="class_p_l_m_d_1_1_plumed.html#ae04f0f7da7efb081b2b2bb66e0ba58da" title="Returns the Plumed global object.">global()</a>) is initialized (i.e. if <a class="el" href="class_p_l_m_d_1_1_plumed.html#a79c0209ed84c21f4c9dba250e0e4163e" title="Initialize global-plumed.">gcreate()</a> has been called), false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#aeb6f7210b2a60b02617e5ec17fe37bfa" title="Check if the global interface has been initialized.">plumed_ginitialized()</a> but returns a bool </dd></dl>

</div>
</div>
<a id="ae04f0f7da7efb081b2b2bb66e0ba58da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04f0f7da7efb081b2b2bb66e0ba58da">&#9670;&nbsp;</a></span>global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::global </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> global object. </p>
<p>Notice that the object is copied, thus increasing the reference counter of the global object. In this manner, the global object will survive after a call to <a class="el" href="class_p_l_m_d_1_1_plumed.html#a2f55a75e3232bad8b71b341f34a87c11">gfinalize()</a> if the resulting object is still in scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> global object </dd></dl>

</div>
</div>
<a id="ab914eefe610aed5b41db61848f3191db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab914eefe610aed5b41db61848f3191db">&#9670;&nbsp;</a></span>gvalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PLMD::Plumed::gvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if global-plumed is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>true if global plumed object (see <a class="el" href="class_p_l_m_d_1_1_plumed.html#ae04f0f7da7efb081b2b2bb66e0ba58da" title="Returns the Plumed global object.">global()</a>) is valid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#a5c0e9b1cd4c2d0761aeb1e82950e7d63" title="Check if global plumed object is valid. Available as of PLUMED 2.5.">plumed_gvalid()</a> but returns a bool </dd></dl>

</div>
</div>
<a id="a03be603fa1dd023719d578bd8ac173ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03be603fa1dd023719d578bd8ac173ad">&#9670;&nbsp;</a></span>incref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&amp; PLMD::Plumed::incref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase reference counter. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Using this method improperly might interfere with correct object construction and destruction. If you want to play with this, also try to compile using <code>-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1</code> and see what happens.</p>
<p>A possible usage is to transfer the ownership of a temporary object when it is converted </p><pre class="fragment">plumed p=Plumed::dlopen(path).incref()
// without incref(), the just constructed object will be destroyed
// when the temporary object is deleted.
... do stuff ...
plumed_finalize(p);
</pre> 
</div>
</div>
<a id="a1bcb66f1ea949d626985b1e6ecfad1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb66f1ea949d626985b1e6ecfad1e9">&#9670;&nbsp;</a></span>installed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PLMD::Plumed::installed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if plumed is installed (for runtime binding) </p>
<dl class="section return"><dt>Returns</dt><dd>true if plumed is installed, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#a74e160dcb16403b500b0c7a7de528ac2" title="Check if plumed is installed (for runtime binding).">plumed_installed()</a> but returns a bool </dd></dl>

</div>
</div>
<a id="a1b13f07c98ea729f77cd8efcb385a877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b13f07c98ea729f77cd8efcb385a877">&#9670;&nbsp;</a></span>make_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::size_t,5&gt; PLMD::Plumed::make_shape </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="struct_p_l_m_d_1_1_plumed_1_1_size_like.html">SizeLike</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal tool to convert initializer_list to shape This is just taking an initializer list and making a std::array. </p>

</div>
</div>
<a id="af6d7939f1aad665d54ea7bc1443edb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d7939f1aad665d54ea7bc1443edb59">&#9670;&nbsp;</a></span>makeInvalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::makeInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_p_l_m_d_1_1_plumed_1_1_invalid.html" title="Thrown when trying to access an invalid plumed object.">Invalid</a> constructor. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Can be used to initialize an invalid object. It might be useful to postpone the initialization of a <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object. Consider the following case </p><pre class="fragment">  Plumed p;
  setenv("PLUMED_KERNEL","/path/to/kernel/libplumedKernel.so",1);
  p.cmd("init")
</pre><p> Here the <code>p</code> object will be initialized <em>before</em> the <code>PLUMED_KERNEL</code> env var has been set. This can be particularly problematic if <code>p</code> is stored in some high level class. The following case would do the job </p><pre class="fragment">  Plumed p;
  setenv("PLUMED_KERNEL","/path/to/kernel/libplumedKernel.so",1);
  p=Plumed();
  p.cmd("init")
</pre><p> However, there will be some error reported related to the attempt to load the kernel when <code>p</code> is initialized. The following solution is the optimal one: </p><pre class="fragment">  Plumed p(Plumed::makeInvalid());
  setenv("PLUMED_KERNEL","/path/to/kernel/libplumedKernel.so",1);
  p=Plumed();
  p.cmd("init")
</pre> 
</div>
</div>
<a id="ad7f46aeedbd60c25c65d1124da92f5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f46aeedbd60c25c65d1124da92f5db">&#9670;&nbsp;</a></span>makeValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> PLMD::Plumed::makeValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a valid <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">PLMD::Plumed</a> object. </p>
<p>Can be used to create a valid object e.g. when Plumed.h was compiled with <code>-D__PLUMED_WRAPPER_CXX_DEFAULT_INVALID</code>. For internal usage. </p>

</div>
</div>
<a id="a10adb1b218dabada64b9333389fe36f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10adb1b218dabada64b9333389fe36f8">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_p_l_m_d_1_1_plumed.html#a1c27732166898a8d219eaba6d399492b">valid()</a>. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Allow code such as </p><pre class="fragment">Plumed p;
if(!p) raise_error();
p.cmd("init");
</pre><p>In order to avoid ambiguous conversions, this is only allowed when compiling with C++11 where it is marked as explicit. </p>

</div>
</div>
<a id="a2189502027361cf9b4ce8ac081a1aa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2189502027361cf9b4ce8ac081a1aa97">&#9670;&nbsp;</a></span>operator plumed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLMD::Plumed::operator <a class="el" href="structplumed.html">plumed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the C plumed structure for this object. </p>
<p>Notice that the resulting plumed structure is a weak reference and should NOT be finalized, unless a new reference is explicitly added </p><pre class="fragment">Plumed p;
plumed c=p;
plumed_finalize(c); // &lt;- this is wrong
</pre> <pre class="fragment">Plumed p;
plumed c=plumed_create_reference(p);
plumed_finalize(c); // &lt;- this is right
</pre> 
</div>
</div>
<a id="afebfbc6a2f2a305e6d295880d5633bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebfbc6a2f2a305e6d295880d5633bdc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&amp; PLMD::Plumed::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Available as of PLUMED 2.5.</p>
<p>Takes a reference,incrementing the reference counter of the corresponding object. </p>

</div>
</div>
<a id="a441119fdb7a182ab645b6fc735caa9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441119fdb7a182ab645b6fc735caa9d3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a>&amp; PLMD::Plumed::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p>Available as of PLUMED 2.5. Only if move semantics is enabled. </p>

</div>
</div>
<a id="a96c623a9e6268c397e160cdefd7d88b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c623a9e6268c397e160cdefd7d88b8">&#9670;&nbsp;</a></span>plumed_cmd_cxx() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_cmd_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="acf2682bf30786af79e28e8fc41367dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2682bf30786af79e28e8fc41367dc7">&#9670;&nbsp;</a></span>plumed_cmd_cxx() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_cmd_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="ade3ce28b9f025bd156ea7efac7800c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3ce28b9f025bd156ea7efac7800c1f">&#9670;&nbsp;</a></span>plumed_cmd_cxx() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_cmd_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="acfa61099a7d884d3b043c6dcfd66b650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa61099a7d884d3b043c6dcfd66b650">&#9670;&nbsp;</a></span>plumed_cmd_cxx() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_cmd_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="a2d3e29d320cd1e01f643e6f64335562f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3e29d320cd1e01f643e6f64335562f">&#9670;&nbsp;</a></span>plumed_cmd_cxx() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_cmd_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed.html">plumed</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="a828abbd8f2b963dec35e8f81ff532114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828abbd8f2b963dec35e8f81ff532114">&#9670;&nbsp;</a></span>plumed_error_rethrow_cxx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void PLMD::Plumed::plumed_error_rethrow_cxx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">This is a tool to rethrow an error as an exception and finalize the error.

In practice, this makes it possible to write a code like this:
```
Plumed p;
plumed_error e;
</pre><p> store error in e if something wrong happes notice that <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> (C++) is implicitly converted to plumed (C) when calling plumed_cmd plumed_cmd(p,"init",&amp;e); do other things here then throw the exception if(e.code) <a class="el" href="wrapper_2_plumed_8h.html#a7eb2b3598939cf1c9a93ec164381661f">plumed_error_rethrow(e)</a>;</p>
<p>It should be used through the macro plumed_error_rethrow. ``` </p>

</div>
</div>
<a id="a73ab885bf74a9d51adf6f3c3af599bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ab885bf74a9d51adf6f3c3af599bb7">&#9670;&nbsp;</a></span>plumed_gcmd_cxx() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_gcmd_cxx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="a83375c8a94f5cd795b93e188a9c105eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83375c8a94f5cd795b93e188a9c105eb">&#9670;&nbsp;</a></span>plumed_gcmd_cxx() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_gcmd_cxx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="wrapper_2_plumed_8h.html#ac784a5f473b6decd7b400ad2498e16f0">__PLUMED_WRAPPER_STD</a> size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="af4c1c8b83f9eaaf9121a077b9cfc313e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c1c8b83f9eaaf9121a077b9cfc313e">&#9670;&nbsp;</a></span>plumed_gcmd_cxx() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PLMD::Plumed::plumed_gcmd_cxx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<a id="aa2f9e23b802d413176d349df9dc07678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f9e23b802d413176d349df9dc07678">&#9670;&nbsp;</a></span>rethrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void PLMD::Plumed::rethrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rethrow the current exception. </p>
<p>This is useful in order to handle an exception thrown by a kernel &lt;=2.4. Only std exceptions are handled, though some of them are thrown as special <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> exceptions in order to be attached a message. </p>

</div>
</div>
<a id="a67390b60953c14548b5b66d14810a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67390b60953c14548b5b66d14810a92a">&#9670;&nbsp;</a></span>rethrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="wrapper_2_plumed_8h.html#a0c4a75222f2dd3abcf407baca0d9d22c">__PLUMED_WRAPPER_CXX_NORETURN</a> void PLMD::Plumed::rethrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive function that rethrows an exception with all the nested ones. </p>
<p>In order to do so, we start throwing from the first exception that was originally thrown and recursively throw the others using throw_with_nested.</p>
<p><a class="el" href="structplumed__error.html" title="Small structure that is only defined locally to retrieve errors.">plumed_error</a> h is finalized at exit by the exception_dispatch function, to avoid memory leaks </p>

</div>
</div>
<a id="af4a1ac84f231646f09c1fe759b9a1370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a1ac84f231646f09c1fe759b9a1370">&#9670;&nbsp;</a></span>toFortran()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PLMD::Plumed::toFortran </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a FORTRAN handler for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The FORTRAN handler (a char[32]). Notice that the resulting plumed structure is a weak reference and should NOT be finalized, unless a new reference is explicitly added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a469d7c35834d0749383986d278958edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469d7c35834d0749383986d278958edb">&#9670;&nbsp;</a></span>toVoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* PLMD::Plumed::toVoid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a void* handler for this object. </p>
<p>Available as of PLUMED 2.5. Notice that the resulting plumed structure is a weak reference and should NOT be finalized, unless a new reference is explicitly added. </p>

</div>
</div>
<a id="a9571fb5e7faacfd5033ff58ab8bf61a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9571fb5e7faacfd5033ff58ab8bf61a1">&#9670;&nbsp;</a></span>useCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PLMD::Plumed::useCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of references to this object. </p>
<p>Available as of PLUMED 2.5. </p><dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#aee275e90bc2549e63205d9643bb8077c" title="Returns the number of references to the underlying object. Available as of PLUMED 2....">plumed_use_count()</a> </dd></dl>

</div>
</div>
<a id="a1c27732166898a8d219eaba6d399492b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c27732166898a8d219eaba6d399492b">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PLMD::Plumed::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <a class="el" href="class_p_l_m_d_1_1_plumed.html" title="C++ wrapper for plumed.">Plumed</a> object is valid. </p>
<p>Available as of PLUMED 2.5 </p><dl class="section return"><dt>Returns</dt><dd>true if plumed is valid, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="structplumed.html#a150967a80004deff89723c6d6ddc2c6c" title="Check if plumed object is valid. Available as of PLUMED 2.5.">plumed_valid()</a> but returns a bool </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ace5f566cbb7d9ca8ecc2f62684342185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5f566cbb7d9ca8ecc2f62684342185">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="a5dba27683c67b1a8278680b1abf9a917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba27683c67b1a8278680b1abf9a917">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="a9a45d4e5589b27b4faa44768234689e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a45d4e5589b27b4faa44768234689e5">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="a8ae3c192ace0d92665acc0c38769e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae3c192ace0d92665acc0c38769e3f1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="afb6df092956c1574f0d61beb93d04ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6df092956c1574f0d61beb93d04ec8">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="ac73314e2956142f1ee76228527683293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73314e2956142f1ee76228527683293">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_l_m_d_1_1_plumed.html">Plumed</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Available as of PLUMED 2.5. </p>

</div>
</div>
<a id="ac1fa53b07c23b79bbeb581f77866a5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fa53b07c23b79bbeb581f77866a5f9">&#9670;&nbsp;</a></span>plumed_gcmd_cxx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void plumed_gcmd_cxx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplumed__error.html">plumed_error</a> *&#160;</td>
          <td class="paramname"><em>error</em> = <code><a class="el" href="wrapper_2_plumed_8h.html#a1f259b8d5d2b2f9fdf9b2704fd7347c2">__PLUMED_WRAPPER_CXX_NULLPTR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These functions can be used to make plumed_cmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">PLMD::Plumed::cmd</a>, namely implement typechecks and rethrowing exception. </p>
<p>This function can be used to make plumed_gcmd behave as the C++ wrapper <a class="el" href="class_p_l_m_d_1_1_plumed.html#ac8745ebf5541c28cb326514009f619a8" title="Send a command to global-plumed.">PLMD::Plumed::gcmd</a>, namely implement typechecks and rethrowing exception. To be used through the macro plumed_gcmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). Available as of PLUMED 2.8. To be used through the macro plumed_cmd (defined when __PLUMED_WRAPPER_CXX_BIND_C==1). They are also used by the <a class="el" href="class_p_l_m_d_1_1_plumed.html#aeafce5a0fd0962ac99de73f8d420c442" title="Send a command to this plumed object.">Plumed::cmd</a> functions to avoid code duplication. Available as of PLUMED 2.8. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a33431ebf1fb7f4047b8045193b84497e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33431ebf1fb7f4047b8045193b84497e">&#9670;&nbsp;</a></span>main</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplumed.html">plumed</a> PLMD::Plumed::main</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>wrapper/<a class="el" href="wrapper_2_plumed_8h.html">Plumed.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<table align="center" frame="void" width="98%" cellpadding="2%">
<tr><td align="left" valign="center"> 
Hosted by GitHub &nbsp;
<a href="http://github.com"><img src="octocat.png" width="88" height="66"  alt="GitHub Logo" /></a>
<!--Generated by  &#160; --> <a href="http://www.doxygen.org/index.html">
</td><td width=90% align="right">
<img class="footer" src="doxygen.png" alt="doxygen" align="right"/>
</a> 1.8.17
</td> </tr> 
</table>
</small></address>
</body>
</html>
