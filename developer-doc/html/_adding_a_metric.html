<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: Implementing methods for calculating the distances between pairs of configurations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../user-doc/html/index.html"> <img src="developer-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementing methods for calculating the distances between pairs of configurations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To implement a new method for calculating the distance between a pair of trajectory frames you will need to work with the PLMD::reference module. This module is used in many parts of PLUMED (e.g. path collective variables, field-cvs and analysis methods). Consequently, if you implement your distance measure using the functionality in this class you will be able to use it in a wide variety of difffernt contexts. As always if you would like us to incorporate your measure in the release version of PLUMED you will need to write at least one regression test for it. Details on how to write regression tests are provided here: <a class="el" href="regtests.html">Adding regressions tests</a> <br  />
</p>
<p>The classes in PLMD::reference allow one to calculate the distance between pairs of trajectory frames. The reason that this is a module rather than a single method is that there are a wide variety of different ways of calculating the distance between two frames. One could, for example, calculate the RMSD distance between the two frames. Alternatively, one can calculate a large number of collective variables and compare the values these variables have in the two configurations. Lastly, one could somehow combine some element of RMSD calculation with the calculation of some set of collective variables. As with so many things the way in which one wishes to calculate the distance between two configurations will depend on the problem one is endeavoring to solve. The aim of the PLMD::reference module is thus to provide the user unlimited flexibility in the way that the matrix of distances can be calculated in analysis methods such as sketch-map or in biasing methods such as path cvs. I say unlimited because, although the particular distance measure the user needs many not currently be implemented in PLUMED, he/she always has the option to implement this new distance metric in the reference module and then access it in the full range of analysis and biasing tools that are already available in the code. The following provides instructions for implementing a new way of calculating the distance between a pair of trajectory frames in the code using the PLMD::reference module. As always once your new method is implemented you can access it in all the places where pairwise distances are employed because of the way that PLUMED exploits inheritance and polymorphism. <br  />
</p>
<h1><a class="anchor" id="adding"></a>
Creating your measure</h1>
<p>To create a new way of measuring the distances between pairs of atoms you must write a new class in the reference directory. An example declaration for such a class is given below:</p>
<pre class="fragment">class OptimalRMSD : public RMSDBase {
private:
  bool fast;
  RMSD myrmsd;
public:
  OptimalRMSD(const ReferenceConfigurationOptions&amp; ro);
  void read( const PDB&amp; );
  double calc( const std::vector&lt;Vector&gt;&amp; pos, const bool&amp; squared );
};
</pre><p>In this case we are inheriting from PLMD::RMSDBase but the particular class you will want to inherit from will depend on the manner in which the distance is calculated. To then ensure that your new measure can be used throughout the code you need to include the MetricRegister.h file and the following line:</p>
<pre class="fragment">PLUMED_REGISTER_METRIC(OptimalRMSD,"OPTIMAL")
</pre><p>Once again dynamic polymorphism is exploited again here. With this example the command above ensures that PLMD::OptimalRMSD objects are used whenever the command METRIC=OPTIMAL is found in the PLUMED input.</p>
<p>Your new class must contain a constructor, a method to read in the configuration from a pdb file (read) and a method to calculate the distance between the reference configuration and the input position (calc). Please be aware that the number of arguments to this method will change depending on which base class you inherit from in creating your new measure object.</p>
<p>The inheritance structure of these routines is rather complicated looking. In essence, however, the base class underlying all these classes in PLMD::ReferenceConfiguration. There are then two classes PLMD::ReferenceArguments and PLMD::ReferenceAtoms that can be multiply inherited in any derived classes. PLMD::ReferenceArguments provides tools for dealing with distance measures that involve colvars. PLMD::ReferenceAtoms provides tools for dealing with distance measures that involve the positions of atoms. Base classes such as PLMD::SingleDomainRMSD and PLMD::RMSDBase are there essentially so that we can use particular sets of metrics in secondary structure variables and the RMSD class respectively. Essentially within these two objects the RMSD is calculated by calling the calc member of the abstract base class PLMD::SingleDomainRMSD and PLMD::RMSDBase. This allows one to use the appropriate set of measures within these particular functions.</p>
<h1><a class="anchor" id="args"></a>
Dealing with colvars</h1>
<p>There are essentially three ways in which you might wish to calculate the distance between two sets of reference colvar values:</p>
<ul>
<li>You will calculate the euclidean distance using pythagoras theorem</li>
<li>You calculate the normalised euclidean distance in which pythagoras theorem is again used but each pair of components is given a separate weight</li>
<li>You calculate the Mahalonobis distance in which the distance is calculated as \(x^T M x\) where \(x\) is the displacement vector and \(M\) is a matrix.</li>
</ul>
<p>These three methods are all implemented within PLUMED and are in the classes PLMD::EuclideanDistance, PLMD::NormalizedEuclideanDistance and PLMD::MahalanobisDistance respectively. If you look in these three classes you will note that there is a very small amount of code in each of them. Essentially the calculation of the distance and the reading in of the PDB file are looked after by the methods PLMD::ReferenceArguments::calculateArgumentDistance and PLMD::ReferenceArguments::readArgumentsFromPDB respectively. To reuse these functionalities you need to add the command:</p>
<ul>
<li>hasmetric=true in the constructor if you want to use the Mahalonobis distance in your new metric</li>
<li>hasweights=true in the constructor if you want to use the normalised euclidean distance in your new metric</li>
</ul>
<p>If you want to use the euclidean distance you can use PLMD::ReferenceArguments::calculateArgumentDistance and PLMD::ReferenceArguments::readArgumentsFromPDB without any further instructions. Notice these methods will still work if you use a combination of atom positions and colvars in your measure. They will give the part of the measure due to the arguments - you will be required to do some further calculation to get the bit involving the atoms.</p>
<h1><a class="anchor" id="atoms"></a>
Dealing with atoms</h1>
<p>All the distance measures that we work with involve the positions of the atoms in the two configurations. If we work with colvars we just do the calculation of the distance from the positions of the atoms in an indirect way - we calculate some intermediary quantities from the positions of the atoms and then calculate the set of difference between these intermediary quantities. There are cases, however, such as when we are working with RMSD distances where it is useful to calculate the distance directly from the set of atomic positions. That is to say there are cases where these intermediary quantities are not useful. If you are implementing such a measure you will need to write a class that inherits from PLMD::ReferenceAtoms either directly or indirectly.</p>
<p>Within the read method you can read the atoms in the PDB file by using the method PLMD::ReferenceAtoms::readAtomsFromPDB. Within calc you can then access the positions of these read in atoms by using the method PLMD::ReferenceAtoms::getReferencePositions() or by using PLMD::ReferenceAtoms::getReferencePosition. It is useful to think carefully about how you can reuse other parts of the code when implementing new reference methods. As an example notice how PLMD::OptimalRMSD and PLMD::SimpleRMSD make extensive use of the <a class="el" href="class_p_l_m_d_1_1_r_m_s_d.html">PLMD::RMSD</a> class. Similarly notice how the PLMD::OptimalRMSD, PLMD::SimpleRMSD and PLMD::DRMSD classes are reused in PLMD::MultiDomainRMSD.</p>
<h1><a class="anchor" id="AddingAMeasureDocs"></a>
Adding documentation for your measure</h1>
<p>To test whether you have implemented you new measure correctly you should implement a small Action that calculates the distance between the instantaneous positions of the atoms and some read in reference configuration. The methods <a class="el" href="class_p_l_m_d_1_1colvar_1_1_r_m_s_d.html" title="Provides the keyword RMSD_SCALAR">PLMD::colvar::RMSD</a>, <a class="el" href="class_p_l_m_d_1_1colvar_1_1_d_r_m_s_d.html" title="Provides the keyword DRMSD">PLMD::colvar::DRMSD</a>, <a class="el" href="class_p_l_m_d_1_1colvar_1_1_multi_r_m_s_d.html" title="Provides the keyword MULTI_RMSD">PLMD::colvar::MultiRMSD</a> and PLMD::function::Target perform these functions for the set of measures that are currently implemented within the reference module. You will need to do something similar in your test action.</p>
<p>You will notice that the documentation in these files starts with the line:</p>
<pre class="fragment">//+PLUMEDOC DCOLVAR TARGET
</pre><p>The DCOLVAR tag is important here as including this tag ensures that the documentation for these objects appears in the appropriate part of the manual. This page of the manual is linked to from all of the pages that exploit the reference module's functionality to provide multiple methods for calculating the distance between two trajectory frames. Any measure that you implement should thus have one of these wrapper actions associated with it and the documentation for the measure should be included in the wrapper code's source code file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<table align="center" frame="void" width="98%" cellpadding="2%">
<tr><td align="left" valign="center"> 
Hosted by GitHub &nbsp;
<a href="http://github.com"><img src="octocat.png" width="88" height="66"  alt="GitHub Logo" /></a>
<!--Generated by  &#160; --> <a href="http://www.doxygen.org/index.html">
</td><td width=90% align="right">
<img class="footer" src="doxygen.png" alt="doxygen" align="right"/>
</a> 1.8.17
</td> </tr> 
</table>
</small></address>
</body>
</html>
